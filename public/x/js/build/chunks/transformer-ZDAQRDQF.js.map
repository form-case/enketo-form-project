{
  "version": 3,
  "sources": ["../../../../../enketo-transformer/src/dom/web/DOMParser.ts", "../../../../../enketo-transformer/src/dom/web/XPathResult.ts", "../../../../../enketo-transformer/src/dom/web/XSLTProcessor.ts", "../../../../../enketo-transformer/src/dom/shared.ts", "../../../../../enketo-transformer/src/xsl/openrosa2html5form.xsl?raw", "../../../../../enketo-transformer/src/xsl/openrosa2xmlmodel.xsl?raw", "../../../../../../node_modules/language-tags/lib/Subtag.js", "../../../../../../node_modules/language-tags/lib/Tag.js", "../../../../../../node_modules/language-tags/lib/index.js", "../../../../../../node_modules/string-direction/index.js", "../../../../../enketo-transformer/src/language.ts", "../../../../../enketo-transformer/src/markdown.ts", "../../../../../enketo-transformer/src/shared.ts", "../../../../../enketo-transformer/src/url.ts", "../../../../../enketo-transformer/src/transformer.ts"],
  "sourcesContent": ["import type { DOM } from '../abstract';\n\n/** @package */\nexport const DOMParser = globalThis.DOMParser satisfies new () => DOM.DOMParser;\n", "import type { DOM } from '../abstract';\n\n/** @package */\nexport const XPathResult =\n    globalThis.XPathResult satisfies new () => DOM.XPathResult;\n", "import type { DOM } from '../abstract';\n\n/** @package */\nexport const XSLTProcessor =\n    globalThis.XSLTProcessor as new () => DOM.XSLTProcessor;\n", "/** @package */\nexport const NodeTypes = {\n    ELEMENT_NODE: 1,\n    ATTRIBUTE_NODE: 2,\n    TEXT_NODE: 3,\n    CDATA_SECTION_NODE: 4,\n    PROCESSING_INSTRUCTION_NODE: 7,\n    COMMENT_NODE: 8,\n    DOCUMENT_NODE: 9,\n    DOCUMENT_TYPE_NODE: 10,\n    DOCUMENT_FRAGMENT_NODE: 11,\n};\n\n/** @package */\nexport type NodeType = (typeof NodeTypes)[keyof typeof NodeTypes];\n", "export default \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\\n<!--\\n*****************************************************************************************************\\nXSLT Stylesheet that transforms OpenRosa style (X)Forms into valid HTMl5 forms\\n(exception: when non-IANA lang attributes are used the form will not validate (but that's not serious))\\n*****************************************************************************************************\\n-->\\n<xsl:stylesheet\\n    xmlns:xsl=\\\"http://www.w3.org/1999/XSL/Transform\\\"\\n    xmlns:xf=\\\"http://www.w3.org/2002/xforms\\\"\\n    xmlns:orx=\\\"http://openrosa.org/xforms\\\"\\n    xmlns:enk=\\\"http://enketo.org/xforms\\\"\\n    xmlns:odk=\\\"http://www.opendatakit.org/xforms\\\"\\n    xmlns:kb=\\\"http://kobotoolbox.org/xforms\\\"\\n    xmlns:esri=\\\"http://esri.com/xforms\\\"\\n    xmlns:oc=\\\"http://openclinica.org/xforms\\\"\\n    xmlns:h=\\\"http://www.w3.org/1999/xhtml\\\"\\n    xmlns:ev=\\\"http://www.w3.org/2001/xml-events\\\"\\n    xmlns:xsd=\\\"http://www.w3.org/2001/XMLSchema\\\"\\n    xmlns:jr=\\\"http://openrosa.org/javarosa\\\"\\n    xmlns:exsl=\\\"http://exslt.org/common\\\"\\n    xmlns:str=\\\"http://exslt.org/strings\\\"\\n    xmlns:dyn=\\\"http://exslt.org/dynamic\\\"\\n    extension-element-prefixes=\\\"exsl str dyn\\\"\\n    version=\\\"1.0\\\"\\n    >\\n    <xsl:param name=\\\"openclinica\\\"/>\\n    <xsl:output method=\\\"html\\\" omit-xml-declaration=\\\"yes\\\" encoding=\\\"UTF-8\\\" indent=\\\"yes\\\"/><!-- for xml: version=\\\"1.0\\\" -->\\n\\n    <xsl:key\\n        name=\\\"bindings-by-id\\\"\\n        match=\\\"/h:html/h:head/xf:model/xf:bind\\\"\\n        use=\\\"@id\\\" />\\n    <xsl:key\\n        name=\\\"nodeset-bindings\\\"\\n        match=\\\"/h:html/h:head/xf:model/xf:bind\\\"\\n        use=\\\"@nodeset\\\" />\\n    <xsl:key\\n        name=\\\"preload-bindings\\\"\\n        match=\\\"/h:html/h:head/xf:model/xf:bind\\\"\\n        use=\\\"@jr:preload != ''\\\" />\\n    <xsl:key\\n        name=\\\"calculate-bindings\\\"\\n        match=\\\"/h:html/h:head/xf:model/xf:bind\\\"\\n        use=\\\"@calculate != ''\\\" />\\n    <xsl:key name=\\\"instances\\\" match=\\\"/h:html/h:head/xf:model/xf:instance\\\" use=\\\"true()\\\" />\\n    <xsl:key\\n        name=\\\"primary-instance-root\\\"\\n        match=\\\"/h:html/h:head/xf:model/xf:instance[1]/child::node()\\\"\\n        use=\\\"true()\\\" />\\n    <xsl:key\\n        name=\\\"model-actions\\\"\\n        match=\\\"/h:html/h:head/xf:model/xf:setvalue[@event] | /h:html/h:head/xf:model/odk:setgeopoint[@event]\\\"\\n        use=\\\"local-name()\\\" />\\n    <xsl:key\\n        name=\\\"fields-by-ref\\\"\\n        match=\\\"/h:html/h:body//xf:input | /h:html/h:body//xf:upload | /h:html/h:body//xf:select | /h:html/h:body//xf:select1\\\"\\n        use=\\\"@ref\\\" />\\n    <xsl:key\\n        name=\\\"default-translation\\\"\\n        match=\\\"/h:html/h:head/xf:model/xf:itext/xf:translation[@default]\\\"\\n        use=\\\"true()\\\" />\\n    <xsl:key\\n        name=\\\"translations\\\"\\n        match=\\\"/h:html/h:head/xf:model/xf:itext/xf:translation\\\"\\n        use=\\\"true()\\\" />\\n    <xsl:key\\n        name=\\\"itext-texts-by-id\\\"\\n        match=\\\"/h:html/h:head/xf:model/xf:itext/xf:translation/xf:text\\\"\\n        use=\\\"@id\\\" />\\n\\n    <xsl:variable name=\\\"upper-case\\\" select=\\\"'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\\\" />\\n    <xsl:variable name=\\\"lower-case\\\" select=\\\"'abcdefghijklmnopqrstuvwxyz'\\\" />\\n    <xsl:variable name=\\\"undefined\\\">undefined</xsl:variable>\\n    <xsl:variable name=\\\"warning\\\">warning</xsl:variable>\\n    <xsl:variable name=\\\"error\\\">error</xsl:variable>\\n    <xsl:variable name=\\\"translated\\\"><!-- assumes that either a whole form is translated or nothing (= real life) -->\\n        <xsl:if test=\\\"count(key('translations', true())) &gt; 1\\\" >\\n            <xsl:value-of select=\\\"string('true')\\\" /><!-- no time to figure out how to use real boolean values -->\\n        </xsl:if>\\n    </xsl:variable>\\n    <xsl:variable name=\\\"default-lang\\\">\\n        <xsl:choose>\\n            <xsl:when test=\\\"key('default-translation', true())/@lang\\\">\\n                <xsl:value-of select=\\\"key('default-translation', true())/@lang\\\" />\\n            </xsl:when>\\n            <xsl:otherwise>\\n                <xsl:value-of select=\\\"''\\\" />\\n            </xsl:otherwise>\\n        </xsl:choose>\\n    </xsl:variable>\\n    <xsl:variable name=\\\"first-lang\\\">\\n        <!-- first language or empty if itext was not used -->\\n        <xsl:value-of select=\\\"key('translations', true())[1]/@lang\\\" />\\n    </xsl:variable>\\n    <xsl:variable name=\\\"current-lang\\\">\\n        <xsl:choose>\\n            <xsl:when test=\\\"string-length($default-lang) > 0\\\">\\n                <xsl:value-of select=\\\"$default-lang\\\" />\\n            </xsl:when>\\n            <xsl:otherwise>\\n                <xsl:value-of select=\\\"$first-lang\\\" />\\n            </xsl:otherwise>\\n        </xsl:choose>\\n    </xsl:variable>\\n\\n    <xsl:template match=\\\"/\\\">\\n        <xsl:if test=\\\"not(function-available('exsl:node-set'))\\\">\\n            <xsl:message terminate=\\\"yes\\\">FATAL ERROR: exsl:node-set function is not available in this XSLT processor</xsl:message>\\n        </xsl:if>\\n        <xsl:for-each select=\\\"/h:html/h:head/xf:model/xf:bind\\\">\\n            <xsl:if test=\\\"not(substring(./@nodeset, 1, 1) = '/')\\\">\\n                <xsl:message terminate=\\\"no\\\">WARNING: Found binding(s) with relative nodeset attribute <!--on element: <xsl:value-of select=\\\"./@nodeset\\\" />--> (form may work correctly if relative nodesets were used consistently throughout xml form in bindings as well as body, otherwise it will certainly be messed up). </xsl:message>\\n            </xsl:if>\\n        </xsl:for-each>\\n       <!--> <xsl:text disable-output-escaping='yes'>&lt;!DOCTYPE html&gt;</xsl:text>\\n        <html>\\n            <head>\\n                <title>\\n                    <xsl:text>Transformation of JR (X)Form to HTML5</xsl:text>\\n                </title>\\n                <script src=\\\"jquery.min.js\\\" type=\\\"text/javascript\\\" ><xsl:text> </xsl:text></script>\\n                <script type=\\\"text/javascript\\\">\\n                    <xsl:text disable-output-escaping='yes'>\\n                      $(function() {\\n                            $('#form-languages a').click(function(){\\n                               $('form [lang]').show().not('[lang=\\\"'+$(this).attr('lang')+'\\\"], [lang=\\\"\\\"], #form-languages a').hide();\\n                            });\\n                      });</xsl:text>\\n                </script>\\n            </head>-->\\n            <root>\\n                <form autocomplete=\\\"off\\\" novalidate=\\\"novalidate\\\" class=\\\"clearfix\\\" dir=\\\"ltr\\\">\\n                    <xsl:attribute name=\\\"class\\\">\\n                        <xsl:value-of select=\\\"'or clearfix'\\\" />\\n                        <xsl:if test=\\\"/h:html/h:body/@class\\\">\\n                            <xsl:value-of select=\\\"concat(' ', /h:html/h:body/@class)\\\" />\\n                        </xsl:if>\\n                    </xsl:attribute>\\n                    <xsl:attribute name=\\\"data-form-id\\\">\\n                        <xsl:choose>\\n                            <xsl:when test=\\\"key('primary-instance-root', true())/@id\\\">\\n                                <xsl:value-of select=\\\"key('primary-instance-root', true())/@id\\\" />\\n                            </xsl:when>\\n                            <xsl:otherwise>\\n                                <xsl:text>_</xsl:text>\\n                            </xsl:otherwise>\\n                        </xsl:choose>\\n                    </xsl:attribute>\\n                    <xsl:if test=\\\"/h:html/h:head/xf:model/xf:submission/@action\\\">\\n                        <xsl:attribute name=\\\"action\\\">\\n                            <xsl:value-of select=\\\"/h:html/h:head/xf:model/xf:submission/@action\\\"/>\\n                        </xsl:attribute>\\n                    </xsl:if>\\n                    <xsl:if test=\\\"/h:html/h:head/xf:model/xf:submission/@method\\\">\\n                        <xsl:attribute name=\\\"method\\\">\\n                            <xsl:choose>\\n                                <xsl:when test=\\\"/h:html/h:head/xf:model/xf:submission/@method = 'form-data-post'\\\">\\n                                     <xsl:value-of select=\\\"'post'\\\"/>\\n                                </xsl:when>\\n                                <xsl:otherwise>\\n                                    <xsl:value-of select=\\\"/h:html/h:head/xf:model/xf:submission/@method\\\"/>\\n                                </xsl:otherwise>\\n                            </xsl:choose>\\n                        </xsl:attribute>\\n                    </xsl:if>\\n                    <xsl:if test=\\\"/h:html/h:head/xf:model/xf:submission/@base64RsaPublicKey\\\">\\n                        <xsl:attribute name=\\\"data-base64RsaPublicKey\\\">\\n                            <xsl:value-of select=\\\"/h:html/h:head/xf:model/xf:submission/@base64RsaPublicKey\\\"/>\\n                        </xsl:attribute>\\n                    </xsl:if>\\n                    <xsl:text>&#10;</xsl:text>\\n                    <xsl:comment>This form was created by transforming an ODK/OpenRosa-flavored (X)Form using an XSL stylesheet created by Enketo LLC.</xsl:comment>\\n                    <section class=\\\"form-logo\\\">\\n                        <xsl:text></xsl:text>\\n                    </section>\\n                    <h3 dir=\\\"auto\\\" id=\\\"form-title\\\">\\n                        <xsl:choose>\\n                            <xsl:when test=\\\"/h:html/h:head/h:title\\\">\\n                                <xsl:value-of select=\\\"/h:html/h:head/h:title\\\"/>\\n                            </xsl:when>\\n                            <xsl:otherwise>\\n                                <xsl:text>No Title</xsl:text>\\n                            </xsl:otherwise>\\n                        </xsl:choose>\\n                    </h3>\\n                <!--\\n                    <div id=\\\"stats\\\" style=\\\"display: none;\\\">\\n                        <span id=\\\"jrSelect\\\"><xsl:value-of select=\\\"count(/h:html/h:body//xf:select)\\\"/></span>\\n                        <span id=\\\"jrSelect1\\\"><xsl:value-of select=\\\"count(/h:html/h:body//xf:select1)\\\"/></span>\\n                        <span id=\\\"jrItemset\\\"><xsl:value-of select=\\\"count(/h:html/h:body//xf:itemset)\\\"/></span>\\n                        <span id=\\\"jrItem\\\"><xsl:value-of select=\\\"count(/h:html/h:body//xf:item)\\\"/></span>\\n                        <span id=\\\"jrInput\\\"><xsl:value-of select=\\\"count(/h:html/h:body//xf:input)\\\"/></span>\\n                        <span id=\\\"jrUpload\\\"><xsl:value-of select=\\\"count(/h:html/h:body//xf:upload)\\\"/></span>\\n                        <span id=\\\"jrTrigger\\\"><xsl:value-of select=\\\"count(/h:html/h:body//xf:trigger)\\\"/></span>\\n                        <span id=\\\"jrRepeat\\\"><xsl:value-of select=\\\"count(/h:html/h:body//xf:repeat)\\\"/></span>\\n                        <span id=\\\"jrRelevant\\\"><xsl:value-of select=\\\"count(/h:html/h:head/xf:model/xf:bind[@relevant])\\\"/></span>\\n                        <span id=\\\"jrConstraint\\\"><xsl:value-of select=\\\"count(/h:html/h:head/xf:model/xf:bind[@constraint])\\\"/></span>\\n                        <span id=\\\"jrCalculate\\\"><xsl:value-of select=\\\"count(/h:html/h:head/xf:model/xf:bind[@calculate])\\\"/></span>\\n                        <span id=\\\"jrPreload\\\"><xsl:value-of select=\\\"count(/h:html/h:head/xf:model/xf:bind[@jr:preload])\\\"/></span>\\n                    </div>\\n                -->\\n                    <xsl:if test=\\\"//*/@lang\\\" >\\n                        <select id=\\\"form-languages\\\">\\n                            <xsl:if test=\\\"$translated != 'true'\\\">\\n                                <xsl:attribute name=\\\"style\\\">display:none;</xsl:attribute>\\n                            </xsl:if>\\n                            <xsl:attribute name=\\\"data-default-lang\\\">\\n                                <xsl:value-of select=\\\"$default-lang\\\" />\\n                            </xsl:attribute>\\n                            <xsl:call-template name=\\\"languages\\\" />\\n                        </select>\\n                    </xsl:if>\\n\\n                    <xsl:apply-templates />\\n\\n                    <!-- Create hidden input fields for preload items that do not have a form control. -->\\n                    <xsl:if test=\\\"key('preload-bindings', true())\\\" >\\n                        <fieldset id=\\\"or-preload-items\\\" style=\\\"display:none;\\\">\\n                            <xsl:apply-templates select=\\\"key('preload-bindings', true())\\\"/>\\n                        </fieldset>\\n                    </xsl:if>\\n\\n                    <!-- Create hidden input fields for calculated items that do not have a form control. -->\\n                    <!-- the template will exclude those that have an input field -->\\n                    <xsl:if test=\\\"key('calculate-bindings', true())\\\">\\n                        <fieldset id=\\\"or-calculated-items\\\" style=\\\"display:none;\\\">\\n                            <xsl:apply-templates select=\\\"key('calculate-bindings', true())\\\" />\\n                        </fieldset>\\n                    </xsl:if>\\n\\n\\n                    <!-- Create hidden input fields for calculated items that do not have a form control. -->\\n                    <!-- the template will exclude those that have an input field -->\\n                    <xsl:if test=\\\"key('model-actions', 'setvalue')\\\">\\n                        <fieldset id=\\\"or-setvalue-items\\\" style=\\\"display:none;\\\">\\n                            <xsl:apply-templates select=\\\"key('model-actions', 'setvalue')\\\" />\\n                        </fieldset>\\n                    </xsl:if>\\n                    <xsl:if test=\\\"key('model-actions', 'setgeopoint')\\\">\\n                        <fieldset id=\\\"or-setgeopoint-items\\\" style=\\\"display:none;\\\">\\n                            <xsl:apply-templates select=\\\"key('model-actions', 'setgeopoint')\\\" />\\n                        </fieldset>\\n                    </xsl:if>\\n                    <!--\\n                    <xsl:if test=\\\"/h:html/h:body//xf:output\\\">\\n                        <xsl:message>WARNING: Output element(s) added but note that only /absolute/path/to/node is properly supported as \\\"value\\\" attribute of outputs. Please test to make sure they do what you want.</xsl:message>\\n                    </xsl:if>\\n                    <xsl:if test=\\\"/h:html/h:body//xf:itemset\\\">\\n                        <xsl:message>WARNING: Itemset support is experimental. Make sure to test whether they do what you want.</xsl:message>\\n                    </xsl:if>\\n                    -->\\n                    <xsl:if test=\\\"//xf:submission\\\">\\n                        <xsl:message>ERROR: Submissions element(s) not supported.</xsl:message>\\n                    </xsl:if>\\n                </form>\\n            </root>\\n        </xsl:template>\\n    <xsl:template match=\\\"h:head\\\"/> <!--[not(self::xf:model/xf:bind[@jr:preload])]\\\" />-->\\n\\n    <xsl:template match=\\\"xf:group\\\">\\n        <!-- NOTE: TO IMPROVE PERFORMANCE, SUPPORT FOR RELATIVE NODESET BINDINGS HAS BEEN SWITCHED OFF\\n            To turn this back on:\\n            - uncomment the variable nodeset_used\\n            - revert back to commented-out code for variable nodeset\\n            - revert back to commented-out code for variable binding\\n            - all this takes place in the next 10 lines\\n        <xsl:variable name=\\\"nodeset_used\\\">\\n            <xsl:call-template name=\\\"nodeset_used\\\" />\\n        </xsl:variable>\\n    -->\\n        <xsl:variable name=\\\"nodeset\\\">\\n            <!--<xsl:call-template name=\\\"nodeset_absolute\\\">\\n                <xsl:with-param name=\\\"nodeset_u\\\" select=\\\"$nodeset_used\\\"/>\\n            </xsl:call-template>-->\\n            <xsl:call-template name=\\\"nodeset_used\\\" />\\n        </xsl:variable>\\n\\n        <!-- note that bindings are not required -->\\n        <!--<xsl:variable name=\\\"binding\\\" select=\\\"/h:html/h:head/xf:model/xf:bind[@nodeset=$nodeset_used] | /h:html/h:head/xf:model/xf:bind[@nodeset=$nodeset]\\\"/>-->\\n        <xsl:variable name=\\\"binding\\\" select=\\\"key('nodeset-bindings', $nodeset)\\\"/>\\n\\n        <section>\\n            <xsl:attribute name=\\\"class\\\">\\n                <!-- only add or-group if label is present or if it has a repeat as child-->\\n                <xsl:choose>\\n                    <xsl:when test=\\\"string(./xf:label/@ref) or string(./xf:label)\\\">\\n                        <xsl:value-of select=\\\"'or-group '\\\" />\\n                    </xsl:when>\\n                    <xsl:otherwise>\\n                        <xsl:value-of select=\\\"'or-group-data '\\\" />\\n                    </xsl:otherwise>\\n                </xsl:choose>\\n                <xsl:if test=\\\"$binding/@relevant\\\">\\n                    <xsl:value-of select=\\\"'or-branch pre-init '\\\"/>\\n                </xsl:if>\\n                <xsl:if test=\\\"@appearance or @rows\\\">\\n                    <xsl:value-of select=\\\"'or-appearances-placeholder '\\\"></xsl:value-of>\\n                </xsl:if>\\n                <!-- Workaround for XLSForm limitation: add \\\"compact\\\" to group if the immediate repeat child has this appearance -->\\n                <!-- This should actually be fixed in pyxform instead -->\\n                <xsl:if test=\\\"contains(./xf:repeat/@appearance, 'compact')\\\">\\n                    <xsl:value-of select=\\\"'or-appearance-compact '\\\"/>\\n                </xsl:if>\\n                <!-- same workaround for \\\"no-collapse\\\" -->\\n                <xsl:if test=\\\"contains(./xf:repeat/@appearance, 'no-collapse')\\\">\\n                    <xsl:value-of select=\\\"'or-appearance-no-collapse '\\\"/>\\n                </xsl:if>\\n            </xsl:attribute>\\n            <xsl:call-template name=\\\"appearance\\\" />\\n\\n            <xsl:if test=\\\"string($nodeset)\\\">\\n                <!--<xsl:variable name=\\\"nodeset\\\" select=\\\"@ref\\\" />-->\\n                <xsl:attribute name=\\\"name\\\">\\n                    <xsl:value-of select=\\\"$nodeset\\\"/>\\n                </xsl:attribute>\\n\\n                <xsl:if test=\\\"$binding/@relevant\\\">\\n                    <xsl:attribute name=\\\"data-relevant\\\">\\n                        <!--<xsl:value-of select=\\\"/h:html/h:head/xf:model/xf:bind[@nodeset=$nodeset]/@relevant\\\" />-->\\n                        <xsl:value-of select=\\\"$binding/@relevant\\\"/>\\n                    </xsl:attribute>\\n                </xsl:if>\\n            </xsl:if>\\n            <xsl:if test=\\\"string(./xf:label/@ref) or string (./xf:label)\\\">\\n                <h4>\\n                    <xsl:apply-templates select=\\\"xf:label\\\" />\\n                </h4>\\n            </xsl:if>\\n            <xsl:apply-templates select=\\\"*[not(self::xf:label or self::xf:hint)]\\\"/>\\n            <xsl:call-template name=\\\"constraint-and-required-msg\\\" >\\n                <xsl:with-param name=\\\"binding\\\" select=\\\"$binding\\\"/>\\n            </xsl:call-template>\\n            <xsl:text>\\n            </xsl:text>\\n        </section><xsl:comment>end of group <xsl:value-of select=\\\"@nodeset\\\" /> </xsl:comment>\\n    </xsl:template>\\n\\n    <xsl:template match=\\\"xf:repeat\\\">\\n    <!-- NOTE: TO IMPROVE PERFORMANCE, SUPPORT FOR RELATIVE NODESET BINDINGS HAS BEEN SWITCHED OFF\\n            To turn this back on:\\n            - uncomment the variable nodeset_used\\n            - revert back to commented-out code for variable nodeset\\n            - revert back to commented-out code for variable binding\\n            - all this takes place in the next 10 lines\\n        <xsl:variable name=\\\"nodeset_used\\\">\\n            <xsl:call-template name=\\\"nodeset_used\\\" />\\n        </xsl:variable>\\n    -->\\n\\n        <!-- the correct absolute nodeset as used in HTML -->\\n        <xsl:variable name=\\\"nodeset\\\">\\n             <!--<xsl:call-template name=\\\"nodeset_absolute\\\">\\n                 <xsl:with-param name=\\\"nodeset_u\\\" select=\\\"$nodeset_used\\\"/>\\n             </xsl:call-template>-->\\n             <xsl:call-template name=\\\"nodeset_used\\\" />\\n        </xsl:variable>\\n\\n        <!-- note that bindings are not required -->\\n        <!--<xsl:variable name=\\\"binding\\\" select=\\\"/h:html/h:head/xf:model/xf:bind[@nodeset=$nodeset_used] | /h:html/h:head/xf:model/xf:bind[@nodeset=$nodeset]\\\" />-->\\n        <!-- Note: not in use, commented out below with \\\"watch out\\\" warning -->\\n        <!-- <xsl:variable name=\\\"binding\\\" select=\\\"key('nodeset-bindings', $nodeset)\\\" /> -->\\n\\n        <section>\\n            <xsl:attribute name=\\\"class\\\">\\n                <xsl:value-of select=\\\"'or-repeat '\\\" />\\n                <!-- watch out or-branch pre-init added to or-group parent! -->\\n                <!--<xsl:if test=\\\"$binding/@relevant\\\">\\n                    <xsl:value-of select=\\\"'or-branch pre-init '\\\"/>\\n                </xsl:if>-->\\n                <xsl:if test=\\\"@appearance or @rows\\\">\\n                    <xsl:value-of select=\\\"'or-appearances-placeholder '\\\"></xsl:value-of>\\n                </xsl:if>\\n            </xsl:attribute>\\n            <xsl:call-template name=\\\"appearance\\\" />\\n            <xsl:attribute name=\\\"name\\\">\\n                <xsl:value-of select=\\\"$nodeset\\\"/>\\n            </xsl:attribute>\\n            <xsl:if test=\\\"string(./xf:label/@ref) or string (./xf:label)\\\">\\n                <h4>\\n                    <xsl:apply-templates select=\\\"xf:label\\\" />\\n                </h4>\\n            </xsl:if>\\n\\n            <xsl:apply-templates select=\\\"*[not(self::xf:label or self::xf:hint)]\\\"/>\\n            <xsl:text>\\n            </xsl:text>\\n        </section>\\n        <!-- Add a repeat-info node -->\\n        <div>\\n            <xsl:attribute name=\\\"class\\\">\\n                <xsl:value-of select=\\\"'or-repeat-info'\\\" />\\n            </xsl:attribute>\\n            <xsl:attribute name=\\\"data-name\\\">\\n                <xsl:value-of select=\\\"$nodeset\\\"/>\\n            </xsl:attribute>\\n            <xsl:if test=\\\"@jr:count\\\">\\n                <xsl:attribute name=\\\"data-repeat-count\\\">\\n                    <xsl:value-of select=\\\"@jr:count\\\" />\\n                </xsl:attribute>\\n            </xsl:if>\\n             <xsl:if test=\\\"@jr:noAddRemove\\\">\\n                <xsl:attribute name=\\\"data-repeat-fixed\\\">\\n                     <xsl:value-of select=\\\"string('fixed')\\\"/>\\n                </xsl:attribute>\\n            </xsl:if>\\n        </div>\\n    </xsl:template>\\n\\n    <xsl:template name=\\\"appearance\\\">\\n        <xsl:variable name=\\\"rows\\\" select=\\\"./@rows\\\" />\\n        <xsl:if test=\\\"local-name() = 'select' or local-name() = 'select1'\\\">\\n            <xsl:attribute name=\\\"data-appearances-select-type\\\" />\\n        </xsl:if>\\n        <xsl:if test=\\\"@appearance or @rows\\\">\\n            <xsl:attribute name=\\\"data-appearances\\\">\\n                <xsl:value-of select=\\\"@appearance\\\" />\\n                <!-- turn rows attribute into an appearance (which is what it should have been in the first place imho) -->\\n                <xsl:if test=\\\"$rows\\\">\\n                    <xsl:value-of select=\\\"concat(' rows-', $rows)\\\" />\\n                </xsl:if>\\n            </xsl:attribute>\\n        </xsl:if>\\n    </xsl:template>\\n\\n\\n    <xsl:template match=\\\"xf:input | xf:upload | xf:range | xf:item | xf:bind[@jr:preload] | xf:bind[@calculate] | xf:setvalue[@event] | odk:setgeopoint[@event]\\\">\\n    <!-- NOTE: TO IMPROVE PERFORMANCE, SUPPORT FOR RELATIVE NODESET BINDINGS HAS BEEN SWITCHED OFF\\n            To turn this back on:\\n            - uncomment the variable nodeset_used\\n            - revert back to commented-out code for variable nodeset\\n            - revert back to commented-out code for variable binding\\n            - all this takes place in the next 10 lines\\n        <xsl:variable name=\\\"nodeset_used\\\">\\n            <xsl:call-template name=\\\"nodeset_used\\\" />\\n        </xsl:variable>\\n    -->\\n        <!-- the correct absolute nodeset as used in HTML -->\\n        <xsl:variable name=\\\"nodeset\\\">\\n             <!--<xsl:call-template name=\\\"nodeset_absolute\\\">\\n                 <xsl:with-param name=\\\"nodeset_u\\\" select=\\\"$nodeset_used\\\"/>\\n             </xsl:call-template>-->\\n             <xsl:call-template name=\\\"nodeset_used\\\" />\\n        </xsl:variable>\\n\\n        <!-- note that bindings are not required -->\\n        <!--<xsl:variable name=\\\"binding\\\" select=\\\"/h:html/h:head/xf:model/xf:bind[@nodeset=$nodeset_used] | /h:html/h:head/xf:model/xf:bind[@nodeset=$nodeset]\\\" />-->\\n        <xsl:variable name=\\\"binding\\\" select=\\\"key('nodeset-bindings', $nodeset)\\\" />\\n\\n        <!-- If this is a bind element that also has an input, do nothing as it will be dealt with by the corresponding xf:input -->\\n        <!-- Note that this test is not fully spec-compliant. It will work with XLS-form produced forms that have no relative nodes\\n             and use the ref atribute only -->\\n        <xsl:if test=\\\"not( local-name() = 'bind' and count( key('fields-by-ref', $nodeset) ) > 0 )\\\">\\n            <xsl:choose>\\n                <xsl:when test=\\\"(local-name() = 'range' and  contains(@appearance, 'picker'))\\\">\\n                    <xsl:call-template name=\\\"select-select\\\">\\n                        <xsl:with-param name=\\\"nodeset\\\" select=\\\"$nodeset\\\" />\\n                        <xsl:with-param name=\\\"binding\\\" select=\\\"$binding\\\" />\\n                    </xsl:call-template>\\n                </xsl:when>\\n                <xsl:otherwise>\\n                    <label>\\n                        <xsl:attribute name=\\\"class\\\">\\n                            <xsl:if test=\\\"local-name() = 'input' or local-name() = 'upload' or local-name() = 'range'\\\">\\n                                <xsl:value-of select=\\\"'question '\\\"/>\\n                            </xsl:if>\\n                            <xsl:if test=\\\"(local-name() = 'input' or local-name() = 'upload' or local-name() = 'range' or local-name() = 'bind') and $binding/@relevant\\\">\\n                                <xsl:value-of select=\\\"'or-branch pre-init '\\\"/>\\n                            </xsl:if>\\n                            <xsl:if test=\\\"local-name() = 'bind'\\\">\\n                                <xsl:value-of select=\\\"'calculation '\\\"/>\\n                            </xsl:if>\\n                            <xsl:if test=\\\"local-name() = 'setvalue'\\\">\\n                                <xsl:value-of select=\\\"'setvalue '\\\"/>\\n                            </xsl:if>\\n                            <xsl:if test=\\\"local-name() = 'setgeopoint'\\\">\\n                                <xsl:value-of select=\\\"'setgeopoint '\\\"/>\\n                            </xsl:if>\\n                            <!--<xsl:if test=\\\"local-name() = 'item'\\\">\\n                                <xsl:value-of select=\\\"'clearfix '\\\"/>\\n                            </xsl:if>-->\\n                            <xsl:if test=\\\"local-name() != 'item'\\\">\\n                                <xsl:value-of select=\\\"'non-select '\\\"/>\\n                            </xsl:if>\\n                            <xsl:if test=\\\"@appearance or @rows\\\">\\n                                <xsl:value-of select=\\\"'or-appearances-placeholder '\\\"></xsl:value-of>\\n                            </xsl:if>\\n                        </xsl:attribute>\\n                        <xsl:call-template name=\\\"appearance\\\" />\\n\\n                        <xsl:apply-templates select=\\\"./@kb:image-customization\\\"/>\\n\\n                        <xsl:if test=\\\"not(local-name() = 'item' or local-name() = 'bind' or local-name() = 'setvalue' or local-name() = 'setgeopoint')\\\">\\n                            <xsl:apply-templates select=\\\"xf:label\\\" />\\n                            <xsl:if test=\\\"not($binding/@readonly = 'true()')\\\">\\n                                <xsl:apply-templates select=\\\"$binding/@required\\\"/>\\n                            </xsl:if>\\n                        </xsl:if>\\n                        <!--\\n                            note: Hints should actually be placed in title attribute (of input) as it is semantically nicer.\\n                            However, to support multiple languages and parse all of them (to be available offline)\\n                            they are placed in the label instead.\\n                        -->\\n                        <xsl:apply-templates select=\\\"xf:hint\\\" />\\n\\n                        <xsl:variable name=\\\"appearance\\\">\\n                            <xsl:value-of select=\\\"translate(@appearance, $upper-case, $lower-case)\\\"/>\\n                        </xsl:variable>\\n                        <xsl:variable name=\\\"element\\\">\\n                            <xsl:choose>\\n                                <xsl:when test=\\\"$binding/@type = 'string' and contains($appearance, 'multi-line') or contains($appearance, 'multiline') or contains($appearance, 'text-area') or contains($appearance, 'textarea') or ./@rows\\\">\\n                                    <xsl:value-of select=\\\"string('textarea')\\\" />\\n                                </xsl:when>\\n                                <xsl:otherwise>\\n                                    <xsl:value-of select=\\\"string('input')\\\" />\\n                                </xsl:otherwise>\\n                            </xsl:choose>\\n                        </xsl:variable>\\n                        <xsl:variable name=\\\"type\\\">\\n                            <xsl:if test=\\\"$element = 'textarea'\\\">\\n                                <xsl:value-of select=\\\"$element\\\"/>\\n                            </xsl:if>\\n                        </xsl:variable>\\n                        <xsl:element name=\\\"{$element}\\\">\\n                            <xsl:choose>\\n                                <xsl:when test=\\\"not(local-name() = 'setvalue' or local-name() = 'setgeopoint') and ancestor::odk:rank\\\">\\n                                    <xsl:call-template name=\\\"rank-item-attributes\\\"/>\\n                                </xsl:when>\\n                                <xsl:when test=\\\"local-name() = 'setvalue' or local-name() = 'setgeopoint'\\\">\\n                                    <xsl:call-template name=\\\"action-attributes\\\">\\n                                        <xsl:with-param name=\\\"binding\\\" select=\\\"$binding\\\"/>\\n                                        <xsl:with-param name=\\\"nodeset\\\" select=\\\"$nodeset\\\"/>\\n                                    </xsl:call-template>\\n                                </xsl:when>\\n                                <xsl:otherwise>\\n                                    <xsl:call-template name=\\\"binding-attributes\\\">\\n                                        <xsl:with-param name=\\\"binding\\\" select=\\\"$binding\\\"/>\\n                                        <xsl:with-param name=\\\"nodeset\\\" select=\\\"$nodeset\\\"/>\\n                                        <xsl:with-param name=\\\"type\\\" select=\\\"$type\\\"/>\\n                                    </xsl:call-template>\\n                                </xsl:otherwise>\\n                            </xsl:choose>\\n                        </xsl:element>\\n                        <xsl:if test=\\\"local-name() = 'item'\\\">\\n                            <xsl:apply-templates select=\\\"xf:label\\\" />\\n                        </xsl:if>\\n\\n                        <xsl:if test=\\\"not(local-name() = 'item' or local-name() = 'bind' or local-name() = 'setvalue' or local-name() = 'setgeopoint')\\\">\\n                            <!-- the only use case at the moment is a <setvalue> and <odk:setgeopoint> child with xforms-value-changed event-->\\n                            <xsl:if test=\\\"./xf:setvalue[@event] or ./odk:setgeopoint[@event]\\\">\\n                                <xsl:apply-templates select=\\\"./xf:setvalue[@event] | ./odk:setgeopoint[@event]\\\" />\\n                            </xsl:if>\\n                            <xsl:call-template name=\\\"constraint-and-required-msg\\\" >\\n                                 <xsl:with-param name=\\\"binding\\\" select=\\\"$binding\\\"/>\\n                            </xsl:call-template>\\n                        </xsl:if>\\n                    </label>\\n                </xsl:otherwise>\\n            </xsl:choose>\\n        </xsl:if>\\n    </xsl:template>\\n\\n    <xsl:template match=\\\"*\\\" mode=\\\"range-option-picker\\\">\\n        <xsl:param name=\\\"start\\\" />\\n        <xsl:param name=\\\"end\\\" />\\n        <xsl:param name=\\\"step\\\" />\\n        <xsl:param name=\\\"readonly\\\" />\\n        <xsl:param name=\\\"limit\\\" />\\n        <xsl:if test=\\\"not($start > $end)\\\">\\n            <option>\\n                <xsl:if test=\\\"$readonly\\\">\\n                    <xsl:attribute name=\\\"disabled\\\">\\n                        <xsl:value-of select=\\\"'disabled'\\\"/>\\n                    </xsl:attribute>\\n                </xsl:if>\\n                <xsl:attribute name=\\\"value\\\">\\n                    <xsl:choose>\\n                        <xsl:when test=\\\"string($start)\\\">\\n                            <xsl:value-of select=\\\"$start\\\" />\\n                        </xsl:when>\\n                        <xsl:otherwise>\\n                            <xsl:message>ERROR: Could not determine value of select option.</xsl:message>\\n                        </xsl:otherwise>\\n                    </xsl:choose>\\n                </xsl:attribute>\\n                <xsl:value-of select=\\\"$start\\\" />\\n            </option>\\n            <span>\\n                <xsl:attribute name=\\\"data-option-value\\\">\\n                    <xsl:value-of select=\\\"$start\\\" />\\n                </xsl:attribute>\\n                <xsl:value-of select=\\\".\\\"/>\\n            </span>\\n            <xsl:variable name=\\\"next\\\" select=\\\"$start + $step\\\"/>\\n            <xsl:choose>\\n                <xsl:when test=\\\"$limit > 1\\\">\\n                    <xsl:apply-templates select=\\\"current()\\\" mode=\\\"range-option-picker\\\">\\n                        <xsl:with-param name=\\\"start\\\" select=\\\"$next\\\"/>\\n                        <xsl:with-param name=\\\"end\\\" select=\\\"$end\\\"/>\\n                        <xsl:with-param name=\\\"step\\\" select=\\\"$step\\\"/>\\n                        <xsl:with-param name=\\\"readonly\\\" select=\\\"$readonly\\\"/>\\n                        <xsl:with-param name=\\\"limit\\\" select=\\\"$limit - 1\\\"/>\\n                    </xsl:apply-templates>\\n                </xsl:when>\\n                <xsl:otherwise>\\n                    <xsl:message>ERROR: Exceed maximum iterations allowed.</xsl:message>\\n                </xsl:otherwise>\\n            </xsl:choose>\\n        </xsl:if>\\n    </xsl:template>\\n\\n    <xsl:template match=\\\"xf:item\\\" mode=\\\"select-option\\\">\\n        <xsl:param name=\\\"tolerate-spaces\\\" />\\n        <xsl:param name=\\\"readonly\\\" />\\n        <xsl:variable name=\\\"label_translations\\\">\\n            <xsl:apply-templates select=\\\"xf:label\\\" />\\n        </xsl:variable>\\n        <xsl:variable name=\\\"value\\\">\\n            <xsl:value-of select=\\\"xf:value\\\" />\\n            <xsl:if test=\\\"not($tolerate-spaces) and contains(xf:value, ' ')\\\">\\n                <xsl:message terminate=\\\"yes\\\">ERROR: (Multi-)select item found with a value that contains spaces!</xsl:message>\\n            </xsl:if>\\n            <xsl:if test=\\\"not(string(xf:value))\\\">\\n                <xsl:message terminate=\\\"no\\\">WARNING: Select item found without a value!</xsl:message>\\n            </xsl:if>\\n        </xsl:variable>\\n        <option>\\n            <xsl:if test=\\\"$readonly\\\">\\n                <xsl:attribute name=\\\"disabled\\\">\\n                    <xsl:value-of select=\\\"'disabled'\\\"/>\\n                </xsl:attribute>\\n            </xsl:if>\\n            <xsl:attribute name=\\\"value\\\">\\n                <xsl:choose>\\n                    <xsl:when test=\\\"string($value)\\\">\\n                        <xsl:value-of select=\\\"$value\\\" />\\n                    </xsl:when>\\n                    <xsl:otherwise>\\n                        <xsl:message>ERROR: Could not determine value of select option.</xsl:message>\\n                    </xsl:otherwise>\\n                </xsl:choose>\\n            </xsl:attribute>\\n            <!-- better to use default language if defined and otherwise span[1] -->\\n            <xsl:choose>\\n                <!-- TODO: IT WOULD BE MORE EFFICIENT TO EXTRACT THIS FROM exsl:node-set($label_translations) -->\\n                <xsl:when test=\\\"exsl:node-set($label_translations)/span[@lang=$current-lang]\\\">\\n                    <xsl:value-of select=\\\"exsl:node-set($label_translations)/span[@lang=$current-lang] \\\" />\\n                </xsl:when>\\n                <xsl:otherwise>\\n                    <xsl:value-of select=\\\"exsl:node-set($label_translations)/span[1] \\\" />\\n                </xsl:otherwise>\\n            </xsl:choose>\\n        </option>\\n        <xsl:for-each select=\\\"exsl:node-set($label_translations)/span\\\" >\\n            <span>\\n                <xsl:attribute name=\\\"data-option-value\\\">\\n                    <xsl:value-of select=\\\"$value\\\" />\\n                </xsl:attribute>\\n                <xsl:attribute name=\\\"lang\\\">\\n                    <xsl:value-of select=\\\"@lang\\\" />\\n                </xsl:attribute>\\n                <xsl:value-of select=\\\".\\\"/>\\n            </span>\\n        </xsl:for-each>\\n    </xsl:template>\\n\\n    <xsl:template match=\\\"xf:itemset\\\" mode=\\\"templates\\\">\\n        <xsl:param name=\\\"nodeset\\\" />\\n        <xsl:param name=\\\"binding\\\"/>\\n        <xsl:param name=\\\"type\\\"/>\\n        <xsl:choose>\\n            <xsl:when test=\\\"not($type = 'option')\\\">\\n                <label class=\\\"itemset-template\\\">\\n                    <xsl:attribute name=\\\"data-items-path\\\">\\n                        <xsl:value-of select=\\\"@nodeset\\\"/>\\n                    </xsl:attribute>\\n                    <!--<xsl:value-of select=\\\"'__LABEL__'\\\" />-->\\n                    <input>\\n                        <xsl:choose>\\n                            <xsl:when test=\\\"ancestor::odk:rank\\\">\\n                                <xsl:call-template name=\\\"rank-item-attributes\\\"/>\\n                            </xsl:when>\\n                            <xsl:otherwise>\\n                                <xsl:call-template name=\\\"binding-attributes\\\">\\n                                    <xsl:with-param name=\\\"binding\\\" select=\\\"$binding\\\"/>\\n                                    <xsl:with-param name=\\\"nodeset\\\" select=\\\"$nodeset\\\"/>\\n                                </xsl:call-template>\\n                            </xsl:otherwise>\\n                        </xsl:choose>\\n                        <xsl:attribute name=\\\"value\\\"></xsl:attribute>\\n                    </input>\\n                </label>\\n            </xsl:when>\\n            <xsl:otherwise>\\n                <option class=\\\"itemset-template\\\" value=\\\"\\\">\\n                    <xsl:attribute name=\\\"data-items-path\\\">\\n                        <xsl:value-of select=\\\"@nodeset\\\"/>\\n                    </xsl:attribute>\\n                    <xsl:if test=\\\"$binding/@readonly = 'true()'\\\">\\n                       <xsl:attribute name=\\\"disabled\\\"/>\\n                    </xsl:if>\\n                    <xsl:value-of select=\\\"'...'\\\"/>\\n                </option>\\n            </xsl:otherwise>\\n        </xsl:choose>\\n    </xsl:template>\\n\\n    <xsl:template match=\\\"xf:itemset\\\" mode=\\\"labels\\\">\\n        <xsl:variable name=\\\"valueRef\\\" select=\\\"@valueRef\\\" />\\n        <xsl:variable name=\\\"labelRef\\\" select=\\\"@labelRef\\\" />\\n        <xsl:variable name=\\\"itextPath\\\" select=\\\"@itextPath\\\" />\\n\\n        <span class=\\\"itemset-labels\\\">\\n            <xsl:attribute name=\\\"data-value-ref\\\">\\n                <xsl:value-of select=\\\"$valueRef\\\"/>\\n            </xsl:attribute>\\n            <xsl:choose>\\n                <xsl:when test=\\\"contains($labelRef, 'jr:itext(')\\\">\\n                    <xsl:attribute name=\\\"data-label-type\\\">\\n                        <xsl:value-of select=\\\"'itext'\\\"/>\\n                    </xsl:attribute>\\n                    <xsl:variable name=\\\"label-node-name\\\"\\n                        select=\\\"substring(substring-after($labelRef, 'itext('),1,string-length(substring-after($labelRef, 'itext('))-1)\\\"/>\\n                    <xsl:attribute name=\\\"data-label-ref\\\">\\n                        <xsl:value-of select=\\\"$label-node-name\\\"/>\\n                    </xsl:attribute>\\n\\n                    <xsl:for-each select=\\\"./*[local-name()=$label-node-name]\\\">\\n                        <!-- so this is support for itext(node) (not itext(path/to/node)), but only 'ad-hoc' for itemset labels for now -->\\n                        <xsl:variable name=\\\"id\\\" select=\\\".\\\" />\\n\\n                        <xsl:call-template name=\\\"translations\\\">\\n                            <xsl:with-param name=\\\"id\\\" select=\\\"$id\\\"/>\\n                            <xsl:with-param name=\\\"class\\\" select=\\\"'option-label'\\\"/>\\n                        </xsl:call-template>\\n                    </xsl:for-each>\\n                </xsl:when>\\n                <xsl:otherwise>\\n                    <xsl:attribute name=\\\"data-label-ref\\\">\\n                        <xsl:value-of select=\\\"$labelRef\\\"/>\\n                    </xsl:attribute>\\n                </xsl:otherwise>\\n            </xsl:choose>\\n            <xsl:text> <!-- This preserves whitespace which affects snapshot tests. --></xsl:text>\\n        </span>\\n    </xsl:template>\\n\\n    <!--\\n       turns STRING: '/path/to/node' into: /*[name()='path'/*[name()='to']/*[name()='node'\\n    -->\\n    <!--\\n    <xsl:template name=\\\"string-to-path\\\">\\n        <xsl:param name=\\\"path-string\\\"/>\\n        <xsl:if test=\\\"starts-with($path-string, '/')\\\">\\n            <xsl:value-of select=\\\"'/'\\\"/>\\n        </xsl:if>\\n        <xsl:choose>\\n            <xsl:when test=\\\"contains($path-string, '/')\\\">\\n                <xsl:value-of select=\\\"substring-before($path-string, '/')\\\"/>\\n                <xsl:call-template name=\\\"string-to-path\\\">\\n                    <xsl:with-param name=\\\"path-string\\\" select=\\\"substring-after($path-string, '/')\\\"/>\\n                </xsl:call-template>\\n            </xsl:when>\\n        </xsl:choose>\\n    </xsl:template>\\n    -->\\n\\n    <xsl:template name=\\\"select-select\\\">\\n        <xsl:param name=\\\"nodeset\\\"/>\\n        <xsl:param name=\\\"binding\\\"/>\\n        <xsl:variable name=\\\"appearance\\\" select=\\\"./@appearance\\\" />\\n        <xsl:variable name=\\\"datalist-id\\\" select=\\\"translate($nodeset, ' _-.\\\\/', '')\\\"/>\\n        <xsl:variable name=\\\"type\\\">\\n           <xsl:choose>\\n               <xsl:when test=\\\"local-name() = 'select'\\\">select_multiple</xsl:when>\\n               <xsl:otherwise>select_one</xsl:otherwise>\\n           </xsl:choose>\\n        </xsl:variable>\\n        <xsl:variable name=\\\"element\\\">\\n            <xsl:choose>\\n                <xsl:when test=\\\"local-name() = 'select1' and (contains(@appearance, 'autocomplete') or contains(@appearance, 'search'))\\\">datalist</xsl:when>\\n                <xsl:otherwise>select</xsl:otherwise>\\n            </xsl:choose>\\n        </xsl:variable>\\n        <xsl:variable name=\\\"options\\\">\\n            <xsl:choose>\\n                <xsl:when test=\\\"contains(@appearance, 'picker')\\\">\\n                    <xsl:apply-templates select=\\\"current()\\\" mode=\\\"range-option-picker\\\">\\n                        <xsl:with-param name=\\\"start\\\" select=\\\"@start\\\" />\\n                        <xsl:with-param name=\\\"end\\\" select=\\\"@end\\\" />\\n                        <xsl:with-param name=\\\"step\\\" select=\\\"@step\\\" />\\n                        <xsl:with-param name=\\\"readonly\\\" select=\\\"$binding/@readonly = 'true()'\\\" />\\n                        <xsl:with-param name=\\\"limit\\\" select=\\\"500\\\" />\\n                    </xsl:apply-templates>\\n                </xsl:when>\\n                <xsl:otherwise>\\n                    <xsl:apply-templates select=\\\"xf:item\\\" mode=\\\"select-option\\\">\\n                        <xsl:with-param name=\\\"tolerate-spaces\\\" select=\\\"$type = 'select_one'\\\" />\\n                        <xsl:with-param name=\\\"readonly\\\" select=\\\"$binding/@readonly = 'true()'\\\" />\\n                    </xsl:apply-templates>\\n                </xsl:otherwise>\\n            </xsl:choose>\\n        </xsl:variable>\\n        <label>\\n            <xsl:attribute name=\\\"class\\\">\\n                <xsl:value-of select=\\\"'question '\\\"/>\\n                <xsl:if test=\\\"./@appearance or ./@rows\\\">\\n                    <xsl:value-of select=\\\"'or-appearances-placeholder '\\\" />\\n                </xsl:if>\\n                <xsl:if test=\\\"$binding/@relevant\\\">\\n                    <xsl:value-of select=\\\"' or-branch pre-init '\\\"/>\\n                </xsl:if>\\n            </xsl:attribute>\\n            <xsl:call-template name=\\\"appearance\\\" />\\n            <xsl:apply-templates select=\\\"./@kb:image-customization\\\"/>\\n            <xsl:apply-templates select=\\\"xf:label\\\" />\\n            <xsl:apply-templates select=\\\"$binding/@required\\\"/>\\n            <xsl:apply-templates select=\\\"xf:hint\\\" />\\n            <xsl:if test=\\\"$element = 'datalist'\\\">\\n                <input>\\n                    <xsl:call-template name=\\\"binding-attributes\\\">\\n                        <xsl:with-param name=\\\"nodeset\\\" select=\\\"$nodeset\\\" />\\n                        <xsl:with-param name=\\\"binding\\\" select=\\\"$binding\\\" />\\n                        <xsl:with-param name=\\\"type\\\" select=\\\"$type\\\" />\\n                    </xsl:call-template>\\n                    <!-- override type attribute -->\\n                    <xsl:attribute name=\\\"type\\\">\\n                        <xsl:value-of select=\\\"'text'\\\"/>\\n                    </xsl:attribute>\\n                    <xsl:attribute name=\\\"list\\\">\\n                        <xsl:value-of select=\\\"$datalist-id\\\"/>\\n                    </xsl:attribute>\\n                </input>\\n            </xsl:if>\\n            <xsl:element name=\\\"{$element}\\\">\\n                <xsl:choose>\\n                    <xsl:when test=\\\"$element != 'datalist'\\\">\\n                        <xsl:call-template name=\\\"binding-attributes\\\">\\n                            <xsl:with-param name=\\\"nodeset\\\" select=\\\"$nodeset\\\" />\\n                            <xsl:with-param name=\\\"binding\\\" select=\\\"$binding\\\" />\\n                            <xsl:with-param name=\\\"type\\\" select=\\\"$type\\\" />\\n                        </xsl:call-template>\\n                    </xsl:when>\\n                    <xsl:otherwise>\\n                        <xsl:attribute name=\\\"id\\\">\\n                            <xsl:value-of select=\\\"$datalist-id\\\"/>\\n                        </xsl:attribute>\\n                    </xsl:otherwise>\\n                </xsl:choose>\\n                <xsl:choose>\\n                    <xsl:when test=\\\"not(./xf:itemset)\\\">\\n                        <option value=\\\"\\\">...</option>\\n                        <xsl:for-each select=\\\"exsl:node-set($options)/option\\\">\\n                            <xsl:copy-of select=\\\".\\\"/>\\n                        </xsl:for-each>\\n                    </xsl:when>\\n                    <xsl:otherwise>\\n                        <xsl:apply-templates select=\\\"xf:itemset\\\" mode=\\\"templates\\\">\\n                            <xsl:with-param name=\\\"binding\\\" select=\\\"$binding\\\"/>\\n                            <xsl:with-param name=\\\"type\\\" select=\\\"'option'\\\"/>\\n                        </xsl:apply-templates>\\n                    </xsl:otherwise>\\n                </xsl:choose>\\n            </xsl:element>\\n            <span class=\\\"or-option-translations\\\" style=\\\"display:none;\\\">\\n                <xsl:if test=\\\"not(./xf:itemset) and $translated = 'true'\\\">\\n                    <xsl:for-each select=\\\"exsl:node-set($options)/span\\\">\\n                        <xsl:copy-of select=\\\".\\\" />\\n                    </xsl:for-each>\\n                </xsl:if>\\n                <xsl:text>\\n                </xsl:text>\\n            </span>\\n            <xsl:if test=\\\"./xf:itemset\\\">\\n                <xsl:apply-templates select=\\\"xf:itemset\\\" mode=\\\"labels\\\"/>\\n            </xsl:if>\\n            <xsl:if test=\\\"./xf:setvalue[@event] or ./odk:setgeopoint[@event]\\\">\\n                <xsl:apply-templates select=\\\"./xf:setvalue[@event] | ./odk:setgeopoint[@event]\\\" />\\n            </xsl:if>\\n            <xsl:call-template name=\\\"constraint-and-required-msg\\\" >\\n                <xsl:with-param name=\\\"binding\\\" select=\\\"$binding\\\"/>\\n            </xsl:call-template>\\n        </label>\\n    </xsl:template>\\n\\n    <xsl:template name=\\\"select-input\\\">\\n        <xsl:param name=\\\"nodeset\\\"/>\\n        <xsl:param name=\\\"binding\\\"/>\\n        <!--\\n            legends are a royal pain-in-the-ass, but semantically correct to use. To restore sanity, the least\\n            ugly solution that works regardless of the legend text + hint length (and showing a nice error background)\\n            is to use a double fieldset (though another outer element would be okay too). Is consequence of being stingy with\\n            # of DOM elements used.\\n        -->\\n        <fieldset>\\n            <xsl:attribute name=\\\"class\\\">\\n                <xsl:value-of select=\\\"'question '\\\"/>\\n                <xsl:if test=\\\"not(contains(@appearance, 'compact') or contains(@appearance, 'list-nolabel') or contains(@appearance, 'label') or contains(@appearance, 'likert') or contains(@appearance, 'horizontal-compact') or contains(@appearance, 'no-buttons'))\\\" >\\n                    <xsl:value-of select=\\\"'simple-select '\\\"/>\\n                </xsl:if>\\n                <xsl:if test=\\\"local-name() = 'trigger'\\\">\\n                    <xsl:value-of select=\\\"'trigger '\\\"/>\\n                </xsl:if>\\n                <xsl:if test=\\\"$binding/@relevant\\\">\\n                    <xsl:value-of select=\\\"'or-branch pre-init '\\\"/>\\n                </xsl:if>\\n                <xsl:if test=\\\"@appearance\\\">\\n                    <xsl:value-of select=\\\"'or-appearances-placeholder '\\\"></xsl:value-of>\\n                </xsl:if>\\n            </xsl:attribute>\\n            <xsl:if test=\\\"@appearance\\\">\\n                <xsl:call-template name=\\\"appearance\\\" />\\n            </xsl:if>\\n            <xsl:apply-templates select=\\\"./@kb:image-customization\\\"/>\\n            <xsl:apply-templates select=\\\"./@kb:flash\\\"/>\\n            <fieldset>\\n                <!--<xsl:if test=\\\"./xf:itemset\\\">\\n                    <xsl:attribute name=\\\"data-itemset\\\"/>\\n                </xsl:if>-->\\n                <legend>\\n                    <xsl:apply-templates select=\\\"xf:label\\\" />\\n                    <xsl:apply-templates select=\\\"$binding/@required\\\"/>\\n                    <xsl:apply-templates select=\\\"xf:hint\\\" />\\n                    <xsl:text>\\n                    </xsl:text>\\n                </legend>\\n                <xsl:if test=\\\"local-name() = 'rank'\\\">\\n                    <input class=\\\"rank\\\">\\n                        <xsl:call-template name=\\\"binding-attributes\\\">\\n                            <xsl:with-param name=\\\"binding\\\" select=\\\"$binding\\\"/>\\n                            <xsl:with-param name=\\\"nodeset\\\" select=\\\"$nodeset\\\"/>\\n                        </xsl:call-template>\\n                    </input>\\n                </xsl:if>\\n                <div class=\\\"option-wrapper\\\">\\n                    <xsl:choose>\\n                        <xsl:when test=\\\"local-name() = 'trigger'\\\">\\n                            <label>\\n                                <input value=\\\"OK\\\">\\n                                    <xsl:call-template name=\\\"binding-attributes\\\">\\n                                        <xsl:with-param name=\\\"binding\\\" select=\\\"$binding\\\"/>\\n                                        <xsl:with-param name=\\\"nodeset\\\" select=\\\"$nodeset\\\"/>\\n                                    </xsl:call-template>\\n                                </input>\\n                                <span class=\\\"option-label active\\\" lang=\\\"\\\">\\n                                    <xsl:value-of select=\\\"'OK'\\\"/>\\n                                </span>\\n                            </label>\\n                        </xsl:when>\\n                        <xsl:when test=\\\"not(./xf:itemset)\\\">\\n                            <xsl:apply-templates select=\\\"xf:item\\\" />\\n                        </xsl:when>\\n                        <xsl:otherwise>\\n                            <xsl:apply-templates select=\\\"xf:itemset\\\" mode=\\\"templates\\\">\\n                                <xsl:with-param name=\\\"nodeset\\\" select=\\\"$nodeset\\\" />\\n                                <xsl:with-param name=\\\"binding\\\" select=\\\"$binding\\\" />\\n                            </xsl:apply-templates>\\n                            <xsl:apply-templates select=\\\"xf:itemset\\\" mode=\\\"labels\\\"/>\\n                        </xsl:otherwise>\\n                    </xsl:choose>\\n                </div>\\n            </fieldset>\\n             <!-- the only use case at the moment is a <setvalue> or <odk:setgeopoint> child with xforms-value-changed event-->\\n            <xsl:if test=\\\"./xf:setvalue[@event] or ./odk:setgeopoint[@event]\\\">\\n                <xsl:apply-templates select=\\\"./xf:setvalue[@event] | ./odk:setgeopoint[@event]\\\" />\\n            </xsl:if>\\n            <xsl:call-template name=\\\"constraint-and-required-msg\\\" >\\n                <xsl:with-param name=\\\"binding\\\" select=\\\"$binding\\\"/>\\n            </xsl:call-template>\\n        </fieldset>\\n    </xsl:template>\\n\\n\\n    <!--\\n        Don't add any logic or names to odk:rank items\\n    -->\\n    <xsl:template name=\\\"rank-item-attributes\\\">\\n        <xsl:attribute name=\\\"value\\\">\\n            <xsl:value-of select=\\\"./xf:value\\\"/>\\n        </xsl:attribute>\\n        <xsl:attribute name=\\\"class\\\">\\n            <xsl:value-of select=\\\"'ignore'\\\"/>\\n        </xsl:attribute>\\n        <xsl:attribute name=\\\"type\\\">\\n            <xsl:value-of select=\\\"'text'\\\"/>\\n        </xsl:attribute>\\n    </xsl:template>\\n\\n    <!--\\n        Don't add any logic or names to setvalue or setgeopoint items\\n    -->\\n    <xsl:template name=\\\"action-attributes\\\">\\n        <xsl:param name=\\\"binding\\\"/>\\n        <xsl:param name=\\\"nodeset\\\"/>\\n        <xsl:attribute name=\\\"name\\\">\\n            <xsl:value-of select=\\\"normalize-space($nodeset)\\\" />\\n        </xsl:attribute>\\n        <xsl:attribute name=\\\"data-type-xml\\\">\\n            <xsl:call-template name=\\\"xml_type\\\">\\n                <xsl:with-param name=\\\"nodeset\\\" select=\\\"$nodeset\\\"/>\\n            </xsl:call-template>\\n        </xsl:attribute>\\n        <xsl:attribute name=\\\"data-event\\\">\\n            <xsl:value-of select=\\\"./@event\\\"/>\\n        </xsl:attribute>\\n        <xsl:choose>\\n            <xsl:when test=\\\"local-name() = 'setvalue'\\\">\\n                <xsl:attribute name=\\\"data-setvalue\\\">\\n                    <xsl:choose>\\n                        <xsl:when test=\\\"./@value\\\">\\n                            <xsl:value-of select=\\\"./@value\\\" />\\n                        </xsl:when>\\n                        <xsl:when test=\\\"string-length(.) > 0\\\">\\n                            <xsl:value-of select=\\\"concat('&quot;', ./text(), '&quot;')\\\" />\\n                        </xsl:when>\\n                    </xsl:choose>\\n                </xsl:attribute>\\n            </xsl:when>\\n            <xsl:when test=\\\"local-name() = 'setgeopoint'\\\">\\n                <xsl:attribute name=\\\"data-setgeopoint\\\">\\n                    <xsl:value-of select=\\\"true()\\\" />\\n                </xsl:attribute>\\n            </xsl:when>\\n        </xsl:choose>\\n        <xsl:attribute name=\\\"type\\\">\\n            <xsl:value-of select=\\\"'hidden'\\\"/>\\n        </xsl:attribute>\\n        <xsl:if test=\\\"$openclinica = 1\\\">\\n            <xsl:for-each select=\\\"$binding/@*[starts-with(name(), 'oc:') and not(substring-before(name(), 'Msg'))]\\\" >\\n                <xsl:attribute name=\\\"{concat('data-oc-', local-name(.))}\\\">\\n                    <xsl:value-of select=\\\"normalize-space(.)\\\" />\\n                </xsl:attribute>\\n            </xsl:for-each>\\n        </xsl:if>\\n    </xsl:template>\\n\\n\\n    <!--\\n        adds binding attributes to the context node, meant for <input>, <select>, <textarea>\\n    -->\\n    <xsl:template name=\\\"binding-attributes\\\">\\n        <xsl:param name=\\\"binding\\\"/>\\n        <xsl:param name=\\\"nodeset\\\"/>\\n        <xsl:param name=\\\"type\\\"/>\\n        <xsl:variable name=\\\"xml-type\\\">\\n            <xsl:call-template name=\\\"xml_type\\\">\\n                <xsl:with-param name=\\\"nodeset\\\" select=\\\"$nodeset\\\"/>\\n                <!--<xsl:with-param name=\\\"binding\\\" select=\\\"$binding\\\"/>-->\\n            </xsl:call-template>\\n        </xsl:variable>\\n        <xsl:variable name=\\\"html-input-type\\\">\\n            <xsl:call-template name=\\\"html_type\\\">\\n                <xsl:with-param name=\\\"xml_type\\\" select=\\\"$xml-type\\\" />\\n            </xsl:call-template>\\n        </xsl:variable>\\n        <xsl:choose>\\n            <xsl:when test=\\\"$type = 'select_multiple'\\\">\\n                <xsl:attribute name=\\\"multiple\\\">multiple</xsl:attribute>\\n            </xsl:when>\\n            <xsl:when test=\\\"$type = 'select_one'\\\"></xsl:when>\\n            <xsl:when test=\\\"$type = 'textarea'\\\"></xsl:when>\\n            <xsl:when test=\\\"$type = 'rank'\\\">\\n                <xsl:attribute name=\\\"type\\\">rank</xsl:attribute>\\n            </xsl:when>\\n            <xsl:otherwise>\\n                <xsl:attribute name=\\\"type\\\">\\n                    <xsl:value-of select=\\\"$html-input-type\\\"/>\\n                </xsl:attribute>\\n            </xsl:otherwise>\\n        </xsl:choose>\\n        <xsl:attribute name=\\\"name\\\">\\n            <xsl:value-of select=\\\"normalize-space($nodeset)\\\" />\\n        </xsl:attribute>\\n        <xsl:if test=\\\"$html-input-type = 'radio'\\\">\\n            <xsl:attribute name=\\\"data-name\\\">\\n                <xsl:value-of select=\\\"normalize-space($nodeset)\\\" />\\n            </xsl:attribute>\\n        </xsl:if>\\n        <xsl:if test=\\\"local-name() = 'item'\\\">\\n            <xsl:attribute name=\\\"value\\\">\\n                <xsl:value-of select=\\\"./xf:value\\\"/>\\n            </xsl:attribute>\\n        </xsl:if>\\n        <xsl:if test=\\\"(string-length($binding/@required) &gt; 0) and not($binding/@required = 'false()') and not(local-name() = 'bind')\\\">\\n            <xsl:attribute name=\\\"data-required\\\">\\n                <xsl:value-of select=\\\"$binding/@required\\\" />\\n            </xsl:attribute>\\n        </xsl:if>\\n        <xsl:if test=\\\"$binding/@constraint\\\">\\n            <xsl:attribute name=\\\"data-constraint\\\">\\n                <xsl:value-of select=\\\"$binding/@constraint\\\" />\\n            </xsl:attribute>\\n        </xsl:if>\\n        <xsl:if test=\\\"$binding/@relevant\\\">\\n            <xsl:attribute name=\\\"data-relevant\\\">\\n                <xsl:value-of select=\\\"$binding/@relevant\\\"/>\\n            </xsl:attribute>\\n        </xsl:if>\\n        <xsl:if test=\\\"$binding/@calculate\\\">\\n            <xsl:attribute name=\\\"data-calculate\\\">\\n                <xsl:value-of select=\\\"$binding/@calculate\\\" />\\n            </xsl:attribute>\\n        </xsl:if>\\n        <xsl:if test=\\\"$binding/@jr:preload\\\">\\n            <xsl:attribute name=\\\"data-preload\\\">\\n                <xsl:value-of select=\\\"$binding/@jr:preload\\\"/>\\n            </xsl:attribute>\\n            <xsl:attribute name=\\\"data-preload-params\\\">\\n                <xsl:value-of select=\\\"$binding/@jr:preloadParams\\\"/>\\n            </xsl:attribute>\\n        </xsl:if>\\n        <xsl:if test=\\\"$binding/@enk:for\\\">\\n            <xsl:attribute name=\\\"data-for\\\">\\n                <xsl:value-of select=\\\"normalize-space($binding/@enk:for)\\\" />\\n            </xsl:attribute>\\n        </xsl:if>\\n        <xsl:if test=\\\"$openclinica = 1\\\">\\n            <xsl:for-each select=\\\"$binding/@*[starts-with(name(), 'oc:') and not(substring-before(name(), 'Msg'))]\\\" >\\n                <xsl:attribute name=\\\"{concat('data-oc-', local-name(.))}\\\">\\n                    <xsl:value-of select=\\\"normalize-space(.)\\\" />\\n                </xsl:attribute>\\n            </xsl:for-each>\\n        </xsl:if>\\n        <xsl:if test=\\\"$binding/@orx:max-pixels\\\">\\n            <xsl:attribute name=\\\"data-max-pixels\\\">\\n                <xsl:value-of select=\\\"normalize-space($binding/@orx:max-pixels)\\\" />\\n            </xsl:attribute>\\n        </xsl:if>\\n        <xsl:attribute name=\\\"data-type-xml\\\">\\n            <xsl:value-of select=\\\"$xml-type\\\" />\\n        </xsl:attribute>\\n        <xsl:if test=\\\"$xml-type = 'decimal'\\\">\\n            <xsl:attribute name=\\\"step\\\">any</xsl:attribute>\\n        </xsl:if>\\n        <xsl:if test=\\\"$binding/@readonly = 'true()' and not($html-input-type = 'hidden')\\\" >\\n            <!--\\n                This also adds a readonly attribute to <select> which is not valid HTML.\\n                We could add some logic to avoid that (the <option>s already get the disabled attribute),\\n                but it's an extra line of defence and doesn't really hurt. The input change handler in\\n                Enketo Core ignores changes on a <select readonly>.\\n            -->\\n            <xsl:attribute name=\\\"readonly\\\">readonly</xsl:attribute>\\n        </xsl:if>\\n        <xsl:if test=\\\"local-name() = 'range'\\\">\\n        <!-- note that due to the unhelpful default value behavior of input type=range in HTML, we use type=number -->\\n            <xsl:if test=\\\"@start\\\">\\n                <xsl:attribute name=\\\"min\\\">\\n                    <xsl:value-of select=\\\"@start\\\" />\\n                </xsl:attribute>\\n            </xsl:if>\\n            <xsl:if test=\\\"@end\\\">\\n                <xsl:attribute name=\\\"max\\\">\\n                    <xsl:value-of select=\\\"@end\\\" />\\n                </xsl:attribute>\\n            </xsl:if>\\n            <xsl:if test=\\\"@step\\\">\\n                <xsl:attribute name=\\\"step\\\">\\n                    <xsl:value-of select=\\\"@step\\\" />\\n                </xsl:attribute>\\n            </xsl:if>\\n        </xsl:if>\\n        <xsl:if test=\\\"$html-input-type = 'file'\\\">\\n            <xsl:attribute name=\\\"accept\\\">\\n                <xsl:choose>\\n                    <xsl:when test=\\\"@accept\\\">\\n                        <xsl:value-of select=\\\"@accept\\\" />\\n                    </xsl:when>\\n                    <xsl:when test=\\\"@mediatype\\\">\\n                        <xsl:value-of select=\\\"@mediatype\\\" />\\n                    </xsl:when>\\n                </xsl:choose>\\n            </xsl:attribute>\\n            <!-- Note, this test captures new, new-front, new-rear -->\\n            <xsl:if test=\\\"contains(@appearance, 'new')\\\">\\n                <xsl:attribute name=\\\"capture\\\">\\n                    <xsl:choose>\\n                        <xsl:when test=\\\"contains(@appearance, 'new-front')\\\">\\n                            <xsl:value-of select=\\\"'user'\\\"/>\\n                        </xsl:when>\\n                        <xsl:when test=\\\"contains(@appearance, 'new-rear')\\\">\\n                            <xsl:value-of select=\\\"'environment'\\\"/>\\n                        </xsl:when>\\n                        <!-- else (if appearance=\\\"new\\\"), the capture attribute remains empty, by design -->\\n                    </xsl:choose>\\n                </xsl:attribute>\\n            </xsl:if>\\n        </xsl:if>\\n    </xsl:template>\\n\\n    <xsl:template match=\\\"xf:select | xf:select1 | odk:rank | xf:trigger\\\">\\n        <xsl:variable name=\\\"nodeset_used\\\">\\n            <xsl:call-template name=\\\"nodeset_used\\\" />\\n        </xsl:variable>\\n        <xsl:variable name=\\\"nodeset\\\">\\n            <xsl:call-template name=\\\"nodeset_absolute\\\">\\n                <xsl:with-param name=\\\"nodeset_u\\\" select=\\\"$nodeset_used\\\"/>\\n            </xsl:call-template>\\n        </xsl:variable>\\n        <xsl:variable name=\\\"binding\\\" select=\\\"key('nodeset-bindings',$nodeset_used) | key('nodeset-bindings', $nodeset)\\\" />\\n        <xsl:choose>\\n            <xsl:when test=\\\"( local-name() = 'select' or local-name() = 'select1' ) and contains(@appearance, 'minimal') or contains(@appearance, 'autocomplete') or contains(@appearance, 'search')\\\">\\n                <xsl:call-template name=\\\"select-select\\\">\\n                    <xsl:with-param name=\\\"nodeset\\\" select=\\\"$nodeset\\\" />\\n                    <xsl:with-param name=\\\"binding\\\" select=\\\"$binding\\\" />\\n                </xsl:call-template>\\n            </xsl:when>\\n            <xsl:otherwise>\\n                <xsl:call-template name=\\\"select-input\\\">\\n                    <xsl:with-param name=\\\"nodeset\\\" select=\\\"$nodeset\\\" />\\n                    <xsl:with-param name=\\\"binding\\\" select=\\\"$binding\\\" />\\n                </xsl:call-template>\\n            </xsl:otherwise>\\n        </xsl:choose>\\n    </xsl:template>\\n\\n    <xsl:template match=\\\"xf:label | xf:hint | xf:bind/@jr:constraintMsg | xf:bind/@jr:requiredMsg | xf:bind/@*[starts-with(name(), 'oc:')]\\\">\\n        <xsl:variable name=\\\"class\\\">\\n            <xsl:choose>\\n                <xsl:when test=\\\"name() = 'jr:constraintMsg'\\\">\\n                    <xsl:value-of select=\\\"'or-constraint-msg'\\\" />\\n                </xsl:when>\\n                <xsl:when test=\\\"local-name() = 'requiredMsg'\\\">\\n                    <xsl:value-of select=\\\"'or-required-msg'\\\" />\\n                </xsl:when>\\n                <xsl:when test=\\\"local-name() = 'relevantMsg'\\\">\\n                    <xsl:value-of select=\\\"'or-relevant-msg'\\\" />\\n                </xsl:when>\\n                <xsl:when test=\\\"local-name() = 'hint'\\\">\\n                    <xsl:value-of select=\\\"'or-hint'\\\" />\\n                </xsl:when>\\n                <xsl:when test=\\\"local-name() = 'label' and local-name(..) != 'item' \\\">\\n                    <xsl:value-of select=\\\"'question-label'\\\"/>\\n                </xsl:when>\\n                <xsl:when test=\\\"local-name() = 'label' and local-name(..) = 'item' \\\">\\n                    <xsl:value-of select=\\\"'option-label'\\\"/>\\n                </xsl:when>\\n                <xsl:when test=\\\"$openclinica = 1 and starts-with(name(), 'oc:constraint') and string-length(local-name()) > 13 and substring(name(), string-length(name()) - string-length('Msg') +1) = 'Msg' \\\" >\\n                    <xsl:value-of select=\\\"concat('or-', substring-before(local-name(.), 'Msg'), '-msg')\\\"/>\\n                </xsl:when>\\n            </xsl:choose>\\n        </xsl:variable>\\n        <xsl:choose>\\n            <xsl:when test=\\\"not(string(./@ref)) and ( string(.) or string(./xf:output/@value) ) and not(contains(.,'itext('))\\\">\\n                <span lang=\\\"\\\">\\n                    <xsl:attribute name=\\\"class\\\">\\n                        <xsl:value-of select=\\\"concat($class, ' active')\\\" />\\n                    </xsl:attribute>\\n                    <xsl:call-template name=\\\"text-content\\\" />\\n                </span>\\n            </xsl:when>\\n            <xsl:otherwise>\\n                <xsl:variable name=\\\"ref\\\">\\n                   <xsl:choose>\\n                        <xsl:when test=\\\"@ref\\\">\\n                            <xsl:value-of select=\\\"@ref\\\" />\\n                        </xsl:when>\\n                        <xsl:otherwise>\\n                            <xsl:value-of select=\\\".\\\" />\\n                        </xsl:otherwise>\\n                    </xsl:choose>\\n                </xsl:variable>\\n\\n                <xsl:variable name=\\\"refid\\\"\\n                    select=\\\"substring(substring-after($ref, 'itext('),2,string-length(substring-after($ref, 'itext('))-3)\\\"/>\\n            <!--\\n                ** HUGE PERFORMANCE HOG! **\\n                <xsl:if test=\\\"not(/h:html/h:head/xf:model/xf:itext/xf:translation/xf:text[@id=$refid])\\\">\\n                    <xsl:message>ERROR: itext(id) found with non-existing id: \\\"<xsl:value-of select=\\\"$refid\\\"/>\\\". Maybe itext(path/to/node) construct was used, which is not supported.</xsl:message>\\n                </xsl:if>\\n            -->\\n                <xsl:call-template name=\\\"translations\\\">\\n                    <xsl:with-param name=\\\"id\\\" select=\\\"$refid\\\"/>\\n                    <xsl:with-param name=\\\"class\\\" select=\\\"$class\\\"/>\\n                </xsl:call-template>\\n            </xsl:otherwise>\\n        </xsl:choose>\\n    </xsl:template>\\n\\n    <xsl:template name=\\\"constraint-and-required-msg\\\">\\n        <xsl:param name=\\\"binding\\\"/>\\n        <xsl:if test=\\\"string-length($binding/@constraint) &gt; 0\\\">\\n            <xsl:choose>\\n                <xsl:when test=\\\"$binding/@jr:constraintMsg\\\">\\n                    <xsl:apply-templates select=\\\"$binding/@jr:constraintMsg\\\" />\\n                </xsl:when>\\n                <xsl:otherwise>\\n                    <xsl:call-template name=\\\"default-constraint-msg\\\"/>\\n                </xsl:otherwise>\\n            </xsl:choose>\\n        </xsl:if>\\n        <xsl:if test=\\\"(string-length($binding/@required) &gt; 0) and not($binding/@required = 'false()')\\\">\\n            <xsl:choose>\\n                <xsl:when test=\\\"$binding/@jr:requiredMsg\\\">\\n                    <xsl:apply-templates select=\\\"$binding/@jr:requiredMsg\\\" />\\n                </xsl:when>\\n                <xsl:otherwise>\\n                    <xsl:call-template name=\\\"default-required-msg\\\"/>\\n                </xsl:otherwise>\\n            </xsl:choose>\\n        </xsl:if>\\n        <xsl:if test=\\\"$openclinica = 1\\\">\\n            <xsl:if test=\\\"(string-length($binding/@relevant) &gt; 0) and not($binding/@relevant = 'true()')\\\">\\n                <xsl:choose>\\n                    <xsl:when test=\\\"$binding/@oc:relevantMsg\\\">\\n                        <xsl:apply-templates select=\\\"$binding/@oc:relevantMsg\\\" />\\n                    </xsl:when>\\n                    <xsl:otherwise>\\n                        <xsl:call-template name=\\\"default-relevant-msg\\\"/>\\n                    </xsl:otherwise>\\n                </xsl:choose>\\n            </xsl:if>\\n            <xsl:for-each select=\\\"$binding/@*[starts-with(name(), 'oc:constraint') and substring(name(), string-length(name()) - string-length('Msg') +1) = 'Msg' ]\\\" >\\n                <xsl:apply-templates select=\\\".\\\" />\\n            </xsl:for-each>\\n        </xsl:if>\\n    </xsl:template>\\n\\n    <xsl:template name=\\\"default-constraint-msg\\\">\\n        <span class=\\\"or-constraint-msg active\\\" lang=\\\"\\\" data-i18n=\\\"constraint.invalid\\\">Value not allowed</span>\\n    </xsl:template>\\n\\n    <xsl:template name=\\\"default-required-msg\\\">\\n        <span class=\\\"or-required-msg active\\\" lang=\\\"\\\" data-i18n=\\\"constraint.required\\\">This field is required</span>\\n    </xsl:template>\\n\\n    <xsl:template name=\\\"default-relevant-msg\\\">\\n        <span class=\\\"or-relevant-msg active\\\" lang=\\\"\\\" data-i18n=\\\"constraint.relevant\\\">This value should be cleared</span>\\n    </xsl:template>\\n\\n    <xsl:template match=\\\"xf:bind/@required\\\">\\n        <xsl:if test=\\\"not(. = 'false()' or string-length(.) = 0)\\\">\\n            <span class=\\\"required\\\">*</span>\\n        </xsl:if>\\n    </xsl:template>\\n\\n     <xsl:template match=\\\"xf:output\\\">\\n        <span class=\\\"or-output\\\">\\n            <xsl:variable name=\\\"itext\\\"\\n                    select=\\\"substring(substring-after(@value, 'itext('),2,string-length(substring-after(@value, 'itext('))-3)\\\"/>\\n            <xsl:attribute name=\\\"data-value\\\">\\n                <!-- this is just a quick hack! Need a robust itext processor that can make a distinction\\n                between id and node and figure out which instance to take node from with multiple instances -->\\n                <xsl:choose>\\n                    <xsl:when test=\\\"string-length($itext) &gt; 0\\\" >\\n                        <xsl:value-of select=\\\"$itext\\\"/>\\n                    </xsl:when>\\n                    <xsl:otherwise>\\n                        <xsl:value-of select=\\\"@value\\\"/>\\n                    </xsl:otherwise>\\n                </xsl:choose>\\n            </xsl:attribute>\\n            <xsl:text><!-- avoids self-closing tags on empty elements --> </xsl:text>\\n        </span>\\n    </xsl:template>\\n\\n    <xsl:template match=\\\"@kb:image-customization\\\">\\n        <xsl:if test=\\\".\\\">\\n            <xsl:attribute name=\\\"data-image-customization\\\">\\n                <xsl:value-of select=\\\"normalize-space(.)\\\" />\\n            </xsl:attribute>\\n        </xsl:if>\\n    </xsl:template>\\n\\n    <xsl:template match=\\\"@kb:flash\\\">\\n        <xsl:if test=\\\".\\\">\\n            <xsl:attribute name=\\\"data-flash\\\">\\n                <xsl:value-of select=\\\"normalize-space(.)\\\" />\\n            </xsl:attribute>\\n        </xsl:if>\\n    </xsl:template>\\n\\n    <xsl:template name=\\\"text-content\\\">\\n        <xsl:choose>\\n            <xsl:when test=\\\"string-length(.) = 0\\\">\\n                <xsl:text><!-- avoids self-closing tags on empty elements --> </xsl:text>\\n                <xsl:apply-templates />\\n            </xsl:when>\\n            <!-- Firefox does not apply templates to these attributes -->\\n            <xsl:when test=\\\"name() = 'jr:constraintMsg' or name() = 'jr:requiredMsg' or ($openclinica = 1 and starts-with(name(), 'oc:') and substring(name(), string-length(name()) - string-length('Msg') + 1) = 'Msg' )\\\">\\n                <xsl:value-of select=\\\".\\\" />\\n            </xsl:when>\\n            <xsl:otherwise>\\n                <xsl:apply-templates />\\n            </xsl:otherwise>\\n        </xsl:choose>\\n    </xsl:template>\\n\\n    <xsl:template name=\\\"translations\\\">\\n        <xsl:param name=\\\"id\\\"/>\\n        <xsl:param name=\\\"class\\\"/>\\n        <xsl:for-each select=\\\"key('itext-texts-by-id', $id)\\\">\\n            <xsl:variable name=\\\"lang\\\" select=\\\"ancestor::xf:translation/@lang\\\"/>\\n            <xsl:variable name=\\\"active\\\">\\n                <xsl:if test=\\\"string($lang) = string($current-lang)\\\">active</xsl:if>\\n            </xsl:variable>\\n            <xsl:variable name=\\\"notext\\\">\\n                <xsl:value-of select=\\\"string-length(./xf:value[@form='long' or @form='short' or not(@form)]) = 0\\\" />\\n            </xsl:variable>\\n            <!-- text labels get priority -->\\n            <xsl:for-each select=\\\"./xf:value\\\" >\\n                <xsl:if test=\\\"not(@form = 'image' or @form = 'video' or @form = 'audio' or @form='big-image' or @form='guidance')\\\">\\n                    <span>\\n                        <xsl:attribute name=\\\"lang\\\">\\n                            <xsl:value-of select=\\\"$lang\\\"/>\\n                        </xsl:attribute>\\n                        <xsl:if test=\\\"string($class) or @form or string($active)\\\">\\n                            <xsl:attribute name=\\\"class\\\">\\n                                <xsl:value-of select=\\\"concat($class, ' ')\\\" />\\n                                <xsl:if test=\\\"@form\\\">\\n                                    <xsl:value-of select=\\\"concat(' or-form-', @form, ' ')\\\" />\\n                                </xsl:if>\\n                                <xsl:if test=\\\"@form = 'long' or (@form = 'short' and not(../node()/@form = 'long')) or not(@form) or @form = 'guidance'\\\">\\n                                    <xsl:value-of select=\\\"$active\\\" />\\n                                </xsl:if>\\n                            </xsl:attribute>\\n                        </xsl:if>\\n                        <xsl:attribute name=\\\"data-itext-id\\\">\\n                            <xsl:value-of select=\\\"$id\\\"/>\\n                        </xsl:attribute>\\n                        <xsl:call-template name=\\\"text-content\\\" />\\n                    </span>\\n                </xsl:if>\\n            </xsl:for-each>\\n            <!-- guidance is next -->\\n            <xsl:for-each select=\\\"./xf:value[@form = 'guidance']\\\">\\n                <details>\\n                    <xsl:attribute name=\\\"lang\\\">\\n                        <xsl:value-of select=\\\"$lang\\\"/>\\n                    </xsl:attribute>\\n                    <xsl:if test=\\\"string($class) or @form or string($active)\\\">\\n                        <xsl:attribute name=\\\"class\\\">\\n                            <xsl:value-of select=\\\"concat($class, ' or-form-', @form, ' ', $active)\\\" />\\n                        </xsl:attribute>\\n                    </xsl:if>\\n                    <summary data-i18n=\\\"hint.guidance.details\\\">more details</summary>\\n                    <xsl:call-template name=\\\"text-content\\\" />\\n                </details>\\n            </xsl:for-each>\\n            <!-- media labels in document order -->\\n            <xsl:for-each select=\\\"./xf:value[@form = 'image' or @form = 'video' or @form = 'audio' and not($class = 'or-hint')]\\\" >\\n                <xsl:choose>\\n                    <xsl:when test=\\\"@form = 'image'\\\" >\\n                        <!-- test if there is a sibling big-image -->\\n                        <xsl:choose>\\n                            <xsl:when test=\\\"../xf:value[@form = 'big-image']\\\" >\\n                                <a>\\n                                    <xsl:attribute name=\\\"class\\\">\\n                                        <xsl:value-of select=\\\"'or-big-image'\\\" />\\n                                    </xsl:attribute>\\n                                    <xsl:attribute name=\\\"href\\\">\\n                                        <xsl:value-of select=\\\"../xf:value[@form = 'big-image']\\\"/>\\n                                    </xsl:attribute>\\n                                    <xsl:call-template name=\\\"image\\\">\\n                                        <xsl:with-param name=\\\"active\\\" select=\\\"$active\\\"/>\\n                                        <xsl:with-param name=\\\"notext\\\" select=\\\"$notext\\\"/>\\n                                        <xsl:with-param name=\\\"lang\\\" select=\\\"$lang\\\"/>\\n                                    </xsl:call-template>\\n                                </a>\\n                            </xsl:when>\\n                            <xsl:otherwise>\\n                                <xsl:call-template name=\\\"image\\\">\\n                                    <xsl:with-param name=\\\"active\\\" select=\\\"$active\\\"/>\\n                                    <xsl:with-param name=\\\"notext\\\" select=\\\"$notext\\\"/>\\n                                    <xsl:with-param name=\\\"lang\\\" select=\\\"$lang\\\"/>\\n                                    <xsl:with-param name=\\\"id\\\" select=\\\"$id\\\"/>\\n                                </xsl:call-template>\\n                            </xsl:otherwise>\\n                        </xsl:choose>\\n                    </xsl:when>\\n                    <xsl:when test=\\\"@form = 'audio'\\\">\\n                        <audio controls=\\\"controls\\\">\\n                            <xsl:attribute name=\\\"lang\\\">\\n                                <xsl:value-of select=\\\"$lang\\\"/>\\n                            </xsl:attribute>\\n                            <xsl:if test=\\\"string($active)\\\">\\n                                <xsl:attribute name=\\\"class\\\">\\n                                    <xsl:value-of select=\\\"$active\\\" />\\n                                </xsl:attribute>\\n                            </xsl:if>\\n                            <xsl:attribute name=\\\"src\\\">\\n                                <xsl:value-of select=\\\".\\\" />\\n                            </xsl:attribute>\\n                            <xsl:attribute name=\\\"data-itext-id\\\">\\n                                <xsl:value-of select=\\\"$id\\\"/>\\n                            </xsl:attribute>\\n                            <xsl:text>Your browser does not support HTML5 audio.</xsl:text>\\n                        </audio>\\n                    </xsl:when>\\n                    <xsl:when test=\\\"@form = 'video'\\\">\\n                        <video controls=\\\"controls\\\">\\n                            <xsl:attribute name=\\\"lang\\\">\\n                                <xsl:value-of select=\\\"$lang\\\"/>\\n                            </xsl:attribute>\\n                            <xsl:if test=\\\"string($active)\\\">\\n                                <xsl:attribute name=\\\"class\\\">\\n                                    <xsl:value-of select=\\\"$active\\\" />\\n                                </xsl:attribute>\\n                            </xsl:if>\\n                            <xsl:attribute name=\\\"src\\\">\\n                                <xsl:value-of select=\\\".\\\" />\\n                            </xsl:attribute>\\n                            <xsl:attribute name=\\\"data-itext-id\\\">\\n                                <xsl:value-of select=\\\"$id\\\"/>\\n                            </xsl:attribute>\\n                            <xsl:text>Your browser does not support HTML5 video.</xsl:text>\\n                        </video>\\n                    </xsl:when>\\n                </xsl:choose>\\n            </xsl:for-each>\\n        </xsl:for-each>\\n    </xsl:template>\\n\\n    <xsl:template name=\\\"strip_namespace\\\">\\n        <xsl:param name=\\\"string\\\" />\\n        <xsl:choose>\\n            <xsl:when test=\\\"contains($string, ':')\\\" >\\n                <!-- crude check, should be improved -->\\n                <xsl:value-of select=\\\"substring-after($string, ':')\\\" />\\n            </xsl:when>\\n            <xsl:otherwise>\\n                <xsl:value-of select=\\\"$string\\\" />\\n            </xsl:otherwise>\\n        </xsl:choose>\\n    </xsl:template>\\n\\n    <xsl:template name=\\\"languages\\\">\\n        <xsl:for-each select=\\\"key('translations', true())\\\" >\\n            <option>\\n                <xsl:attribute name=\\\"value\\\">\\n                    <xsl:value-of select=\\\"@lang\\\"/>\\n                </xsl:attribute>\\n                <xsl:value-of select=\\\"@lang\\\" />\\n            </option>\\n            <xsl:text> </xsl:text>\\n        </xsl:for-each>\\n    </xsl:template>\\n\\n    <!-- future support for itext node parameters -->\\n    <xsl:template name=\\\"itext-helper\\\">\\n\\n    </xsl:template>\\n\\n    <xsl:template name=\\\"node-path-helper\\\">\\n        <xsl:param name=\\\"input-node\\\"/>\\n        <xsl:choose>\\n            <xsl:when test=\\\"$input-node/@bind\\\">\\n                <xsl:variable name=\\\"id\\\" select=\\\"$input-node/@bind\\\" />\\n                <xsl:value-of select=\\\"key('bindings-by-id', $id)/@nodeset\\\"/>\\n            </xsl:when>\\n            <xsl:when test=\\\"$input-node/@ref or $input-node/@nodeset\\\">\\n                <xsl:variable name=\\\"path\\\" select=\\\"normalize-space($input-node/@ref | $input-node/@nodeset)\\\" />\\n                <xsl:if test=\\\"not(substring($path, 1, 1) = '/') and not(parent::h:body)\\\" >\\n                    <!-- path is relative, so we need context -->\\n                    <!--<xsl:choose>-->\\n                        <!-- should ancestor:: be replaced with parent:: ??? TEST -->\\n                       <!-- <xsl:when test=\\\"parent::xf:repeat/@nodeset\\\">\\n                            <xsl:value-of select=\\\"concat(ancestor::xf:repeat/@nodeset, '/')\\\" />\\n                        </xsl:when>\\n                        <xsl:when test=\\\"parent::xf:repeat/@ref\\\">\\n                            <xsl:value-of select=\\\"concat(ancestor::xf:repeat/@ref, '/')\\\" />\\n                        </xsl:when>\\n                        <xsl:when test=\\\"parent::xf:group/@nodeset\\\">\\n                            <xsl:value-of select=\\\"concat(ancestor::xf:group/@nodeset, '/')\\\" />\\n                        </xsl:when>\\n                        <xsl:when test=\\\"parent::xf:group/@ref\\\">\\n                            <xsl:value-of select=\\\"concat(ancestor::xf:group/@ref, '/')\\\" />\\n                        </xsl:when>-->\\n                        <!-- and use top level instance node, if the ancestor is h:body -->\\n                        <!--<xsl:when test=\\\"parent::h:body\\\">-->\\n                            <!-- start with the top level element of the instance, e.g. /data/ -->\\n                        <!--    <xsl:value-of select=\\\"concat('/', local-name(//xf:instance/child::*[1]), '/')\\\" />-->\\n                            <!--<xsl:message>INFO: tried to add top level node of instance:<xsl:value-of select=\\\"local-name(//xf:instance/child::*[1])\\\"/></xsl:message>-->\\n                        <!--</xsl:when>-->\\n                        <!--<xsl:otherwise>\\n                            <xsl:message>ERROR: Could not determine context node for relative path.</xsl:message>\\n                        </xsl:otherwise>\\n                    </xsl:choose>-->\\n                    <xsl:for-each select=\\\"ancestor::*\\\">\\n                       <!-- <xsl:if test=\\\"not(substring($path, 1, 1) = '/') and not(local-name() = 'body') \\\">-->\\n\\n                        <!--<xsl:message>ancestor: <xsl:value-of select=\\\"local-name()\\\" /></xsl:message>-->\\n                        <xsl:if test=\\\"(local-name() = 'repeat' or local-name() = 'group')\\\">\\n\\n                                <!--substring(@nodeset, 1, 1) = '/' or substring(@ref, 1, 1) = '/'\\n                                        )\\\">-->\\n                            <!--<xsl:for-each select=\\\"descendant::*\\\">\\n                                <xsl:if test=\\\"local-name() = 'group' or local-name() = 'repeat'\\\">-->\\n                                <xsl:if test=\\\"string-length(@ref) &gt; 0 or string-length(@nodeset) &gt; 0\\\">\\n                                    <xsl:value-of select=\\\"concat(@ref,@nodeset, '/')\\\" />\\n                                </xsl:if>\\n                            <!--    </xsl:if>\\n                            </xsl:for-each>-->\\n                            <!-- not totally foolproof (will fail if nested group use both local and absolute paths) but probably okay, test this with multiple nested groups -->\\n                        </xsl:if>\\n                        <!--</xsl:if>-->\\n                    </xsl:for-each>\\n                </xsl:if>\\n                <xsl:value-of select=\\\"$path\\\"/>\\n            </xsl:when>\\n            <!-- if a group without @ref but with an immediate repeat child is used (ODK Build) -->\\n            <xsl:when test=\\\"local-name() = 'group' and $input-node/xf:repeat/@nodeset\\\">\\n                <xsl:value-of select=\\\"$input-node/xf:repeat/@nodeset\\\" />\\n            </xsl:when>\\n            <!--<xsl:otherwise>\\n                <xsl:message>ERROR: Could not determine node path for <xsl:value-of select=\\\"local-name($input-node)\\\" /></xsl:message>\\n            </xsl:otherwise>-->\\n        </xsl:choose>\\n    </xsl:template>\\n\\n    <!--<xsl:template name=\\\"one-step-back\\\">\\n        <xsl:param name=\\\"path\\\" />\\n        <xsl:param name=\\\"node\\\" />\\n        <xsl:variable name=\\\"newpath\\\">\\n            <xsl:choose>\\n                <xsl:when test=\\\"parent::xf:repeat/@nodeset\\\">\\n                    <xsl:value-of select=\\\"concat(ancestor::xf:repeat/@nodeset, '/', $path)\\\" />\\n                </xsl:when>\\n                <xsl:when test=\\\"parent::xf:repeat/@ref\\\">\\n                    <xsl:value-of select=\\\"concat(ancestor::xf:repeat/@ref, '/', $path)\\\" />\\n                </xsl:when>\\n                <xsl:when test=\\\"parent::xf:group/@nodeset\\\">\\n                    <xsl:value-of select=\\\"concat(ancestor::xf:group/@nodeset, '/', $path)\\\" />\\n                </xsl:when>\\n                <xsl:when test=\\\"parent::xf:group/@ref\\\">\\n                    <xsl:value-of select=\\\"concat(ancestor::xf:group/@ref, '/', $path)\\\" />\\n                </xsl:when>\\n                <xsl:otherwise>\\n                    strictly speaking, if the parent group or repeat doesn't have a ref/nodeset, we should go\\n                    one level higher. Not implemented here.\\n                    <xsl:message>ERROR: Could not determine context node for relative path.</xsl:message>\\n                </xsl:otherwise>\\n            <xsl:choose>\\n        </xsl:variable>\\n        <xsl:if test=\\\"not(substring($path, 1, 1) = '/') and not(parent::h:body)\\\">\\n            <xsl:call-template name=\\\"one-step-back\\\" >\\n                <xsl:with-param name=\\\"path\\\" select=\\\"$newpath\\\"/>\\n                <xsl:with-param name=\\\"node\\\" select=\\\"parent::*\\\"/>\\n            </xsl:call-template>\\n        </xsl:if>\\n        <xsl:value-of select=\\\"$newpath\\\" />\\n    </xsl:template>-->\\n\\n    <xsl:template name=\\\"image\\\">\\n        <xsl:param name=\\\"active\\\"/>\\n        <xsl:param name=\\\"notext\\\" />\\n        <xsl:param name=\\\"lang\\\"/>\\n        <xsl:param name=\\\"id\\\"/>\\n         <!-- add empty span for option-labels that have no text, just an image, to support the new radio buttons and checkboxes -->\\n         <xsl:if test=\\\"$notext = 'true'\\\" >\\n             <span>\\n                 <xsl:attribute name=\\\"lang\\\">\\n                     <xsl:value-of select=\\\"$lang\\\"/>\\n                 </xsl:attribute>\\n                 <xsl:attribute name=\\\"class\\\">\\n                     <xsl:value-of select=\\\"'option-label '\\\"/>\\n                     <xsl:if test=\\\"string($active)\\\">\\n                         <xsl:value-of select=\\\"$active\\\"/>\\n                     </xsl:if>\\n                 </xsl:attribute>\\n                 <xsl:text>\\n                 </xsl:text>\\n             </span>\\n         </xsl:if>\\n         <img>\\n             <xsl:attribute name=\\\"lang\\\">\\n                 <xsl:value-of select=\\\"$lang\\\"/>\\n             </xsl:attribute>\\n             <xsl:if test=\\\"string($active)\\\">\\n                 <xsl:attribute name=\\\"class\\\">\\n                     <xsl:value-of select=\\\"$active\\\" />\\n                 </xsl:attribute>\\n             </xsl:if>\\n             <xsl:attribute name=\\\"src\\\">\\n                 <xsl:value-of select=\\\".\\\" />\\n             </xsl:attribute>\\n             <xsl:attribute name=\\\"data-itext-id\\\">\\n                <xsl:value-of select=\\\"$id\\\"/>\\n            </xsl:attribute>\\n             <xsl:attribute name=\\\"alt\\\">image</xsl:attribute>\\n         </img>\\n    </xsl:template>\\n\\n    <xsl:template name=\\\"nodeset_used\\\">\\n        <xsl:choose>\\n            <!-- first the simplest case (for preload or calculated fields taken from bind elements) -->\\n            <xsl:when test=\\\"local-name() = 'bind'\\\">\\n                <!--<xsl:choose>-->\\n                    <!-- if nodeset value is relative -->\\n                    <!--<xsl:when test=\\\"not(substring(./@nodeset, 1, 1) = '/')\\\">-->\\n                        <!-- start with the top level element of the instance, e.g. /data/ -->\\n                    <!--    <xsl:value-of select=\\\"concat('/', local-name(//xf:instance/child::*[1]), '/')\\\" />\\n                    </xsl:when>\\n                    <xsl:otherwise />\\n                </xsl:choose>-->\\n                <xsl:value-of select=\\\"./@nodeset\\\"/>\\n            </xsl:when>\\n            <!-- then for input elements -->\\n            <xsl:otherwise>\\n                <xsl:variable name=\\\"intermediate\\\">\\n                    <xsl:choose>\\n                        <xsl:when test=\\\"not(local-name() = 'setvalue' or local-name() = 'setgeopoint') and ( local-name(..) = 'select1' or local-name(..) = 'select' )\\\">\\n                            <xsl:call-template name=\\\"node-path-helper\\\">\\n                                <xsl:with-param name=\\\"input-node\\\" select=\\\"..\\\" />\\n                            </xsl:call-template>\\n                        </xsl:when>\\n                        <xsl:otherwise>\\n                            <xsl:call-template name=\\\"node-path-helper\\\">\\n                                <xsl:with-param name=\\\"input-node\\\" select=\\\".\\\" />\\n                            </xsl:call-template>\\n                        </xsl:otherwise>\\n                    </xsl:choose>\\n                </xsl:variable>\\n                <!-- now strip anything preceding a // which occurs e.g. in widgets.xml-->\\n                <!-- note that this goes only 1 level deep so is not reliable enough -->\\n                <xsl:choose>\\n                    <xsl:when test=\\\"contains($intermediate, '//')\\\">\\n                        <xsl:value-of select=\\\"concat('/', substring-after($intermediate, '//'))\\\"/>\\n                    </xsl:when>\\n                    <xsl:otherwise>\\n                        <xsl:value-of select=\\\"$intermediate\\\"/>\\n                    </xsl:otherwise>\\n                </xsl:choose>\\n            </xsl:otherwise>\\n        </xsl:choose>\\n    </xsl:template>\\n\\n    <xsl:template name=\\\"nodeset_absolute\\\">\\n        <xsl:param name=\\\"nodeset_u\\\"/>\\n        <xsl:variable name=\\\"nodeset_a\\\">\\n            <xsl:choose>\\n                <xsl:when test=\\\"not(substring($nodeset_u, 1, 1) = '/')\\\">\\n                    <xsl:value-of select=\\\"concat('/', local-name(key('primary-instance-root', true())[1]), '/', $nodeset_u)\\\"/>\\n            <!--<xsl:message terminate=\\\"yes\\\">ERROR: Could not determine absolute path/to/instance/node (terminated transformation), found: <xsl:value-of select=\\\"$nodeset\\\" />.</xsl:message>-->\\n                </xsl:when>\\n                <xsl:otherwise>\\n                    <xsl:value-of select=\\\"$nodeset_u\\\" />\\n                </xsl:otherwise>\\n            </xsl:choose>\\n        </xsl:variable>\\n        <xsl:if test=\\\"not($nodeset_u = $nodeset_a)\\\">\\n            <!--<xsl:message>INFO: changed relative nodeset: <xsl:value-of select=\\\"$nodeset_u\\\"/> to: <xsl:value-of select=\\\"$nodeset_a\\\" /></xsl:message>-->\\n        </xsl:if>\\n        <xsl:value-of select=\\\"$nodeset_a\\\"/>\\n    </xsl:template>\\n\\n    <xsl:template name=\\\"xml_type\\\">\\n        <xsl:param name=\\\"nodeset\\\" />\\n        <!--<xsl:param name=\\\"binding\\\" />-->\\n        <xsl:variable name=\\\"xml_type\\\">\\n            <!--<xsl:value-of select=\\\"$binding\\\"/>-->\\n            <xsl:value-of select=\\\"key('nodeset-bindings', $nodeset)/@type\\\" />\\n        </xsl:variable>\\n        <xsl:choose>\\n            <xsl:when test=\\\"string-length($xml_type) &lt; 1\\\" >string</xsl:when>\\n            <xsl:otherwise>\\n                <xsl:call-template name=\\\"strip_namespace\\\">\\n                    <xsl:with-param name=\\\"string\\\">\\n                        <xsl:value-of select=\\\"$xml_type\\\"/>\\n                    </xsl:with-param>\\n                </xsl:call-template>\\n            </xsl:otherwise>\\n        </xsl:choose>\\n    </xsl:template>\\n\\n    <!-- ONLY TO BE USED FOR INPUT ELEMENT TYPES -->\\n    <xsl:template name=\\\"html_type\\\">\\n        <xsl:param name=\\\"xml_type\\\" />\\n        <xsl:choose>\\n            <xsl:when test=\\\"local-name(..) = 'select1' or $xml_type='select1' or local-name(.) = 'trigger'\\\">radio</xsl:when>\\n            <xsl:when test=\\\"local-name(..) = 'select' or $xml_type='select'\\\">checkbox</xsl:when>\\n            <xsl:when test=\\\"local-name() = 'bind'\\\">hidden</xsl:when>\\n            <xsl:when test=\\\"local-name() = 'range'\\\">number</xsl:when>\\n            <xsl:when test=\\\"$xml_type = 'dateTime'\\\">datetime-local</xsl:when>\\n            <xsl:when test=\\\"$xml_type = 'date'\\\">date</xsl:when>\\n            <!-- note, it may not actually be possible to support 'file' with offline storage -->\\n            <xsl:when test=\\\"$xml_type = 'binary'\\\">file</xsl:when>\\n            <xsl:when test=\\\"$xml_type = 'time'\\\">time</xsl:when>\\n            <xsl:when test=\\\"$xml_type = 'rank'\\\">text</xsl:when>\\n            <xsl:when\\n                test=\\\"$xml_type = 'decimal' or $xml_type = 'float' or $xml_type = 'double' or $xml_type = 'int' or $xml_type = 'integer'\\\"\\n                >number</xsl:when>\\n            <xsl:when test=\\\"$xml_type = 'string' and contains(./@appearance, 'numbers')\\\">tel</xsl:when>\\n            <xsl:when test=\\\"$xml_type = 'string'\\\">text</xsl:when>\\n            <xsl:when test=\\\"$xml_type = 'barcode' or $xml_type = 'geopoint' or $xml_type = 'geotrace' or $xml_type = 'geoshape'\\\" >\\n                <xsl:value-of select=\\\"string('text')\\\" />\\n            </xsl:when>\\n            <xsl:otherwise>\\n                <xsl:value-of select=\\\"$error\\\"/>\\n                <xsl:message terminate=\\\"no\\\">ERROR: Unsupported data type '<xsl:value-of select=\\\"$xml_type\\\"/>' found.</xsl:message>\\n            </xsl:otherwise>\\n        </xsl:choose>\\n    </xsl:template>\\n</xsl:stylesheet>\\n\"", "export default \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\\n<!--\\n*****************************************************************************************************\\nXSLT Stylesheet that transforms OpenRosa style (X)Forms instance to an xml instance that can be used\\ninside Enketo Smart Paper.\\n*****************************************************************************************************\\n-->\\n\\n<!-- \\nThese namespace-declarations have been carefully crafted to produce a fairly clean output. \\nThis includes the duplicate default namespace and xf: prefixed namespace. \\nEdit with care!\\n-->\\n<xsl:stylesheet xmlns:xsl=\\\"http://www.w3.org/1999/XSL/Transform\\\" \\n    xmlns:xf=\\\"http://www.w3.org/2002/xforms\\\" \\n    xmlns:h=\\\"http://www.w3.org/1999/xhtml\\\" \\n    xmlns:ev=\\\"http://www.w3.org/2001/xml-events\\\" \\n    xmlns:xsd=\\\"http://www.w3.org/2001/XMLSchema\\\" \\n    xmlns=\\\"http://www.w3.org/2002/xforms\\\" version=\\\"1.0\\\">\\n    <xsl:output method=\\\"xml\\\" indent=\\\"yes\\\" omit-xml-declaration=\\\"yes\\\" version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" />\\n\\n    <xsl:template match=\\\"/\\\">\\n        <root>\\n            <model>\\n                <xsl:apply-templates select=\\\"//xf:model/@*\\\" mode=\\\"include-namespace-declarations\\\"/>\\n                <xsl:apply-templates select=\\\"//xf:model/xf:instance\\\" />\\n            </model>\\n        </root>\\n    </xsl:template>\\n\\n    <xsl:template match=\\\"xf:instance\\\">\\n        <instance>\\n            <xsl:apply-templates select=\\\"@*\\\"/>\\n            <!-- \\n            This forces namespace declarations on the child of instance, which makes it easier to\\n            serialize that child for a submission without duplications of namespace declarations.\\n            -->\\n            <xsl:copy-of select=\\\"node()\\\" />\\n        </instance>\\n    </xsl:template>\\n\\n    <xsl:template match=\\\"@*\\\">\\n        <xsl:attribute name=\\\"{name()}\\\">\\n            <xsl:value-of select=\\\".\\\" />\\n        </xsl:attribute>\\n    </xsl:template>\\n\\n    <xsl:template match=\\\"@*\\\" mode=\\\"include-namespace-declarations\\\">\\n        <xsl:copy-of select=\\\".\\\"/>\\n    </xsl:template>\\n\\n</xsl:stylesheet>\\n\"", "/**\n * @author Matthew Caruana Galizia <m@m.cg>\n * @license MIT: http://mattcg.mit-license.org/\n * @copyright Copyright (c) 2013, Matthew Caruana Galizia\n */\n\n/*jshint node:true*/\n\n'use strict';\n\nvar index = require('language-subtag-registry/data/json/index');\nvar registry = require('language-subtag-registry/data/json/registry');\n\nmodule.exports = Subtag;\n\nSubtag.ERR_NONEXISTENT = 1;\nSubtag.ERR_TAG = 2;\n\nfunction Subtag(subtag, type) {\n\tvar types, i, record, error;\n\n\t// Lowercase for consistency (case is only a formatting convention, not a standard requirement).\n\tsubtag = subtag.toLowerCase();\n\ttype = type.toLowerCase();\n\n\terror = function(code, message) {\n\t\tvar err;\n\n\t\terr = new Error(message);\n\t\terr.code = code;\n\t\terr.subtag = subtag;\n\t\tthrow err;\n\t};\n\n\ttypes = index[subtag];\n\tif (!types) {\n\t\terror(Subtag.ERR_NONEXISTENT, 'Non-existent subtag \\'' + subtag + '\\'.');\n\t}\n\n\ti = types[type];\n\tif (!i && 0 !== i) {\n\t\terror(Subtag.ERR_NONEXISTENT, 'Non-existent subtag \\'' + subtag + '\\' of type \\'' + type + '\\'.');\n\t}\n\n\trecord = registry[i];\n\tif (!record.Subtag) {\n\t\terror(Subtag.ERR_TAG, '\\'' + subtag + '\\' is a \\'' + type + '\\' tag.');\n\t}\n\n\tthis.data = {};\n\tthis.data.subtag = subtag;\n\tthis.data.record = record;\n\tthis.data.type = type;\n}\n\nSubtag.prototype.type = function() {\n\treturn this.data.type;\n};\n\nSubtag.prototype.descriptions = function() {\n\n\t// Every record has one or more descriptions (stored as an array).\n\treturn this.data.record.Description;\n};\n\nSubtag.prototype.preferred = function() {\n\tvar type, preferred = this.data.record['Preferred-Value'];\n\n\tif (preferred) {\n\t\ttype = this.data.type;\n\t\tif (type === 'extlang') {\n\t\t\ttype = 'language';\n\t\t}\n\n\t\treturn new Subtag(preferred, type);\n\t}\n\n\treturn null;\n};\n\nSubtag.prototype.script = function() {\n\tvar script = this.data.record['Suppress-Script'];\n\n\tif (script) {\n\t\treturn new Subtag(script, 'script');\n\t}\n\n\treturn null;\n};\n\nSubtag.prototype.scope = function() {\n\treturn this.data.record.Scope || null;\n};\n\nSubtag.prototype.deprecated = function() {\n\treturn this.data.record.Deprecated || null;\n};\n\nSubtag.prototype.added = function() {\n\treturn this.data.record.Added;\n};\n\nSubtag.prototype.comments = function() {\n\n\t// Comments don't always occur for records, so switch to an empty array if missing.\n\treturn this.data.record.Comments || [];\n};\n\nSubtag.prototype.format = function() {\n\tvar subtag = this.data.subtag;\n\n\tswitch (this.data.type) {\n\tcase 'region':\n\t\treturn subtag.toUpperCase();\n\tcase 'script':\n\t\treturn subtag[0].toUpperCase() + subtag.substr(1);\n\t}\n\n\treturn subtag;\n};\n\nSubtag.prototype.toString = function() {\n\treturn this.format();\n};\n", "/**\n * @author Matthew Caruana Galizia <m@m.cg>\n * @license MIT: http://mattcg.mit-license.org/\n * @copyright Copyright (c) 2013, Matthew Caruana Galizia\n */\n\n/*jshint node:true*/\n\n'use strict';\n\nvar index = require('language-subtag-registry/data/json/index');\nvar registry = require('language-subtag-registry/data/json/registry');\n\nvar Subtag = require('./Subtag');\n\nmodule.exports = Tag;\n\nTag.ERR_DEPRECATED = 1;\nTag.ERR_NO_LANGUAGE = 2;\nTag.ERR_UNKNOWN = 3;\nTag.ERR_TOO_LONG = 4;\nTag.ERR_EXTRA_REGION = 5;\nTag.ERR_EXTRA_EXTLANG = 6;\nTag.ERR_EXTRA_SCRIPT = 7;\nTag.ERR_DUPLICATE_VARIANT = 8;\nTag.ERR_WRONG_ORDER = 9;\nTag.ERR_SUPPRESS_SCRIPT = 10;\nTag.ERR_SUBTAG_DEPRECATED = 11;\nTag.ERR_EXTRA_LANGUAGE = 12;\n\nfunction Tag(tag) {\n\tvar types;\n\n\t// Lowercase for consistency (case is only a formatting convention, not a standard requirement).\n\ttag = tag.trim().toLowerCase();\n\n\tthis.data = {};\n\tthis.data.tag = tag;\n\n\t// Check if the input tag is grandfathered or redundant.\n\ttypes = index[tag];\n\tif (types && (types.grandfathered || types.redundant)) {\n\t\tthis.data.record = registry[types.grandfathered || types.redundant];\n\t}\n}\n\nTag.prototype.preferred = function() {\n\tvar preferred = this.data.record['Preferred-Value'];\n\n\tif (preferred) {\n\t\treturn new Tag(preferred);\n\t}\n\n\treturn null;\n};\n\nTag.prototype.subtags = function() {\n\tvar codes, data = this.data, subtags = [];\n\n\t// No subtags if the tag is grandfathered.\n\tif (data.record && this.type() === 'grandfathered') {\n\t\treturn subtags;\n\t}\n\n\tcodes = data.tag.split('-');\n\tif (!codes.length) {\n\t\treturn subtags;\n\t}\n\n\t// Try and find the language tag.\n\tcodes.some(function(code, i) {\n\t\tvar types;\n\n\t\t// Singletons and anything after are unhandled.\n\t\tif (code.length < 2) {\n\t\t\treturn true; // Stop the loop (stop processing after a singleton).\n\t\t}\n\n\t\ttypes = index[code];\n\n\t\t// Check for non-existent tag.\n\t\tif (!types) {\n\t\t\treturn; // Skip to the next item.\n\t\t}\n\n\t\t// Check against undefined because value could be 0.\n\t\t// Language subtags may only appear at the beginning of the tag, otherwise the subtag type is indeterminate.\n\t\tif (0 === i && undefined !== types.language) {\n\t\t\tsubtags.push(new Subtag(code, 'language'));\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (code.length) {\n\t\tcase 2:\n\n\t\t\t// Should be a region.\n\t\t\tif (types.region) {\n\t\t\t\tsubtags.push(new Subtag(code, 'region'));\n\n\t\t\t// Error case: language subtag in the wrong place.\n\t\t\t} else if (types.language) {\n\t\t\t\tsubtags.push(new Subtag(code, 'language'));\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase 3:\n\n\t\t\t// Could be a numeric region code e.g. '001' for 'World'.\n\t\t\tif (types.region) {\n\t\t\t\tsubtags.push(new Subtag(code, 'region'));\n\t\t\t} else if (types.extlang) {\n\t\t\t\tsubtags.push(new Subtag(code, 'extlang'));\n\n\t\t\t// Error case: language subtag in the wrong place.\n\t\t\t} else if (types.language) {\n\t\t\t\tsubtags.push(new Subtag(code, 'language'));\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase 4:\n\n\t\t\t// Could be a numeric variant.\n\t\t\tif (types.variant) {\n\t\t\t\tsubtags.push(new Subtag(code, 'variant'));\n\t\t\t} else if (types.script) {\n\t\t\t\tsubtags.push(new Subtag(code, 'script'));\n\t\t\t}\n\n\t\t\tbreak;\n\t\tdefault:\n\n\t\t\t// Should be a variant.\n\t\t\tif (types.variant) {\n\t\t\t\tsubtags.push(new Subtag(code, 'variant'));\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t});\n\n\treturn subtags;\n};\n\nTag.prototype.language = function() {\n\treturn this.find('language');\n};\n\nTag.prototype.region = function() {\n\treturn this.find('region');\n};\n\nTag.prototype.script = function() {\n\treturn this.find('script');\n};\n\nTag.prototype.find = function(type) {\n\tvar i, l, subtag, subtags = this.subtags();\n\n\tfor (i = 0, l = subtags.length; i < l; i++) {\n\t\tsubtag = subtags[i];\n\n\t\tif (subtag.type() === type) {\n\t\t\treturn subtag;\n\t\t}\n\t}\n};\n\nTag.prototype.valid = function() {\n\treturn this.errors().length < 1;\n};\n\nTag.prototype.errors = function() {\n\tvar error, subtags, data = this.data, errors = [];\n\n\terror = function(code, subtag) {\n\t\tvar err, message;\n\n\t\tswitch (code) {\n\t\tcase Tag.ERR_DEPRECATED:\n\t\t\tmessage = 'The tag \\'' + data.tag + '\\' is deprecated.';\n\n\t\t\t// Note that a record that contains a 'Deprecated' field and no corresponding 'Preferred-Value' field has no replacement mapping (RFC 5646 section 3.1.6).\n\t\t\tif (data.record['Preferred-Value']) {\n\t\t\t\tmessage += ' Use \\'' + data.record['Preferred-Value'] + '\\' instead.';\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase Tag.ERR_SUBTAG_DEPRECATED:\n\t\t\tmessage = 'The subtag \\'' + subtag + '\\' is deprecated.';\n\t\t\tbreak;\n\t\tcase Tag.ERR_NO_LANGUAGE:\n\t\t\tif (!data.tag) {\n\t\t\t\tmessage = 'Empty tag.';\n\t\t\t} else {\n\t\t\t\tmessage = 'Missing language tag in \\'' + data.tag + '\\'.';\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase Tag.ERR_UNKNOWN:\n\t\t\tmessage = 'Unknown code \\'' + subtag + '\\'';\n\t\t\tbreak;\n\t\tcase Tag.ERR_TOO_LONG:\n\t\t\tmessage = 'The private-use subtag \\'' + subtag + '\\' is too long.';\n\t\t\tbreak;\n\t\tcase Tag.ERR_EXTRA_LANGUAGE:\n\t\tcase Tag.ERR_EXTRA_EXTLANG:\n\t\tcase Tag.ERR_EXTRA_REGION:\n\t\tcase Tag.ERR_EXTRA_SCRIPT:\n\t\t\tmessage = 'Extra ' + subtag.type() + ' subtag \\'' + subtag + '\\' found.';\n\t\t\tbreak;\n\t\tcase Tag.ERR_DUPLICATE_VARIANT:\n\t\t\tmessage = 'Duplicate variant subtag \\'' + subtag + '\\' found.';\n\t\t\tbreak;\n\t\tcase Tag.ERR_WRONG_ORDER:\n\t\t\tmessage = 'The subtag \\'' + subtag[0] + '\\' should not appear before \\'' + subtag[1] + '\\'.';\n\t\t\tbreak;\n\t\tcase Tag.ERR_SUPPRESS_SCRIPT:\n\t\t\tmessage = 'The script subtag \\'' + subtag + '\\' is the same as the language suppress-script.';\n\t\t\tbreak;\n\t\t}\n\n\t\terr = new Error(message);\n\t\terr.code = code;\n\t\terr.tag = data.tag;\n\t\terr.subtag = subtag;\n\t\terrors.push(err);\n\t};\n\n\t// Check if the tag is grandfathered and if the grandfathered tag is deprecated (e.g. no-nyn).\n\tif (data.record) {\n\t\tif (data.record.Deprecated) {\n\t\t\terror(Tag.ERR_DEPRECATED);\n\t\t}\n\n\t\t// Only check every subtag if the tag is not explicitly listed as grandfathered or redundant.\n\t\treturn errors;\n\t}\n\n\t// Check that all subtag codes are meaningful.\n\tdata.tag.split('-').some(function(code, i, codes) {\n\t\tvar types;\n\n\t\t// Ignore anything after a singleton.\n\t\tif (code.length < 2) {\n\n\t\t\t// Check that each private-use subtag is within the maximum allowed length.\n\t\t\tcodes.slice(i).forEach(function(code) {\n\t\t\t\tif (code.length > 8) {\n\t\t\t\t\terror(Tag.ERR_TOO_LONG, code);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn true;\n\t\t}\n\n\t\ttypes = index[code];\n\t\tif (!types) {\n\t\t\terror(Tag.ERR_UNKNOWN, code);\n\t\t}\n\n\t\treturn false; // Continue to the next item.\n\t});\n\n\t// Check that first tag is a language tag.\n\tsubtags = this.subtags();\n\tif (!subtags.length || 'language' !== subtags[0].type()) {\n\t\terror(Tag.ERR_NO_LANGUAGE);\n\t\treturn errors;\n\t}\n\n\t// Check for more than one of some types and for deprecation.\n\tsubtags.forEach(function(subtag, i) {\n\t\tvar type = subtag.type(), language, script, found = this;\n\n\t\tif (subtag.deprecated()) {\n\t\t\terror(Tag.ERR_SUBTAG_DEPRECATED, subtag);\n\t\t}\n\n\t\tif (found[type]) {\n\t\t\tfound[type].push(subtag);\n\t\t}\n\n\t\tswitch (type) {\n\t\tcase 'language':\n\t\t\tif (found.language.length > 1) {\n\t\t\t\terror(Tag.ERR_EXTRA_LANGUAGE, subtag);\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase 'region':\n\t\t\tif (found.region.length > 1) {\n\t\t\t\terror(Tag.ERR_EXTRA_REGION, subtag);\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase 'extlang':\n\t\t\tif (found.extlang.length > 1) {\n\t\t\t\terror(Tag.ERR_EXTRA_EXTLANG, subtag);\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase 'script':\n\t\t\tif (found.script.length > 1) {\n\t\t\t\terror(Tag.ERR_EXTRA_SCRIPT, subtag);\n\n\t\t\t// Check if script is same as language suppress-script.\n\t\t\t} else {\n\t\t\t\tlanguage = subtags[0];\n\t\t\t\tif ('language' === language.type()) {\n\t\t\t\t\tscript = language.script();\n\t\t\t\t\tif (script && script.format() === subtag.format()) {\n\t\t\t\t\t\terror(Tag.ERR_SUPPRESS_SCRIPT, subtag);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase 'variant':\n\t\t\tif (found.variant.length > 1 && found.variant.some(function(variant) {\n\t\t\t\treturn variant.format() === subtag.format();\n\t\t\t})) {\n\t\t\t\terror(Tag.ERR_DUPLICATE_VARIANT, subtag);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tlanguage: [],\n\t\textlang: [],\n\t\tvariant: [],\n\t\tscript: [],\n\t\tregion: []\n\t});\n\n\t// Check for correct order.\n\tsubtags.forEach(function(subtag, i, subtags) {\n\t\tvar priority = this, next = subtags[i + 1];\n\n\t\tif (next && priority[subtag.type()] > priority[next.type()]) {\n\t\t\terror(Tag.ERR_WRONG_ORDER, [subtag, next]);\n\t\t}\n\t}, {\n\t\tlanguage: 4,\n\t\textlang: 5,\n\t\tscript: 6,\n\t\tregion: 7,\n\t\tvariant: 8\n\t});\n\n\treturn errors;\n};\n\nTag.prototype.type = function() {\n\tvar record = this.data.record;\n\n\tif (record) {\n\t\treturn record.Type;\n\t}\n\n\treturn 'tag';\n};\n\nTag.prototype.added = function() {\n\tvar record = this.data.record;\n\n\treturn record && record.Added;\n};\n\nTag.prototype.deprecated = function() {\n\tvar record = this.data.record;\n\n\treturn record && record.Deprecated;\n};\n\nTag.prototype.descriptions = function() {\n\tvar record = this.data.record;\n\n\tif (record && record.Description) {\n\t\treturn record.Description;\n\t}\n\n\treturn [];\n};\n\nTag.prototype.format = function() {\n\tvar tag = this.data.tag;\n\n\t// Format according to algorithm defined in RFC 5646 section 2.1.1.\n\treturn tag.split('-').reduce(function(p, c, i, a) {\n\t\tif (i === 0) {\n\t\t\treturn c;\n\t\t}\n\n\t\tif (a[i - 1].length === 1) {\n\t\t\treturn p + '-' + c;\n\t\t}\n\n\t\tswitch (c.length) {\n\t\tcase 2:\n\t\t\treturn p + '-' + c.toUpperCase();\n\t\tcase 4:\n\t\t\treturn p + '-' + c[0].toUpperCase() + c.substr(1);\n\t\t}\n\n\t\treturn p + '-' + c;\n\t});\n};\n", "/**\n * @author Matthew Caruana Galizia <m@m.cg>\n * @license MIT: http://mattcg.mit-license.org/\n * @copyright Copyright (c) 2013, Matthew Caruana Galizia\n */\n\n/*jshint node:true*/\n\n'use strict';\n\nvar Tag = require('./Tag');\nvar Subtag = require('./Subtag');\n\nvar index = require('language-subtag-registry/data/json/index');\nvar registry = require('language-subtag-registry/data/json/registry');\n\nvar tags = function(tag) {\n\treturn new Tag(tag);\n};\n\nmodule.exports = tags;\n\ntags.check = function(tag) {\n\treturn new Tag(tag).valid();\n};\n\ntags.types = function(subtag) {\n\tvar types = index[subtag];\n\n\tif (!types) {\n\t\treturn [];\n\t}\n\n\treturn Object.keys(types).filter(function(type) {\n\t\treturn type !== 'grandfathered' && type !== 'redundant';\n\t});\n};\n\ntags.subtags = function(subtags) {\n\tvar result = [];\n\n\tif (!Array.isArray(subtags)) {\n\t\tsubtags = [subtags];\n\t}\n\n\tsubtags.forEach(function(subtag) {\n\t\ttags.types(subtag).forEach(function(type) {\n\t\t\tresult.push(new Subtag(subtag, type));\n\t\t});\n\t});\n\n\treturn result;\n};\n\ntags.filter = function(subtags) {\n\treturn subtags.filter(function(subtag) {\n\t\treturn !tags.types(subtag).length;\n\t});\n};\n\ntags.search = function(query, all) {\n\tvar test;\n\n\tif ('function' === typeof query.test) {\n\t\ttest = function(description) {\n\t\t\treturn query.test(description);\n\t\t};\n\n\t// If the query is all lowercase, make a case-insensitive match.\n\t} else if (query.toLowerCase() === query) {\n\t\ttest = function(description) {\n\t\t\treturn -1 !== description.toLowerCase().indexOf(query);\n\t\t};\n\t} else {\n\t\ttest = function(description) {\n\t\t\treturn -1 !== description.indexOf(query);\n\t\t};\n\t}\n\n\treturn registry.filter(function(record) {\n\t\tif (!record.Subtag && !all) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn record.Description.some(test);\n\n\t// Sort by matched description string length.\n\t// This is a quick way to push precise matches towards the top.\n\t}).sort(function(a, b) {\n\t\treturn Math.min.apply(Math, a.Description.filter(test).map(function(description) {\n\t\t\treturn description.length;\n\t\t})) - Math.min.apply(Math, b.Description.filter(test).map(function(description) {\n\t\t\treturn description.length;\n\t\t}));\n\t}).map(function(record) {\n\t\tif (record.Subtag) {\n\t\t\treturn new Subtag(record.Subtag, record.Type);\n\t\t}\n\n\t\treturn new Tag(record.Tag);\n\t});\n};\n\ntags.languages = function(macrolanguage) {\n\tvar i, l, record, results = [];\n\n\tmacrolanguage = macrolanguage.toLowerCase();\n\tif (!require('language-subtag-registry/data/json/macrolanguage')[macrolanguage]) {\n\t\tthrow new Error('\\'' + macrolanguage + '\\' is not a macrolanguage.');\n\t}\n\n\tfor (i = 0, l = registry.length; i < l; i++) {\n\t\trecord = registry[i];\n\t\tif (record.Macrolanguage === macrolanguage) {\n\t\t\tresults.push(new Subtag(record.Subtag, record.Type));\n\t\t}\n\t}\n\n\treturn results;\n};\n\ntags.language = function(subtag) {\n\treturn tags.type(subtag, 'language');\n};\n\ntags.region = function(subtag) {\n\treturn tags.type(subtag, 'region');\n};\n\ntags.type = function(subtag, type) {\n\tvar types = index[subtag.toLowerCase()];\n\n\tif (types && types[type]) {\n\t\treturn new Subtag(subtag, type);\n\t}\n\n\treturn null;\n};\n\ntags.date = function() {\n\treturn require('language-subtag-registry/data/json/meta')['File-Date'];\n};\n", "(function(){\n\n  var LTR_MARK = \"\\u200e\",\n      RTL_MARK = \"\\u200f\",\n      LTR = 'ltr', // Left to right direction content\n      RTL = 'rtl', // Right to left direction content\n      BIDI = 'bidi', // Both directions - any and all directions will not be ok\n      NODI = ''; // No direction - any and all directions are ok\n\n  var rtlSciriptRanges = {\n    Hebrew:   [\"0590\",\"05FF\"],\n    Arabic:   [\"0600\",\"06FF\"],\n    NKo:      [\"07C0\",\"07FF\"],\n    Syriac:   [\"0700\",\"074F\"],\n    Thaana:   [\"0780\",\"07BF\"],\n    Tifinagh: [\"2D30\",\"2D7F\"]\n  };\n\n  /*\n   * Gets string direction\n   * @param {string} - String to check for direction\n   * @returns {string} - 'ltr' if given string is left-to-right, \n   * 'rtl' if it's right-to-left and 'bidi' if it has both types of characters \n  */\n  function getDirection(string) {\n\n    if(typeof string === 'undefined')\n      throw new Error('TypeError missing argument');\n\n    if(typeof string !== 'string')\n      throw new Error('TypeError getDirection expects strings');\n\n    if(string === '')\n      return NODI;\n      \n    if(string.indexOf(LTR_MARK) > -1 && string.indexOf(RTL_MARK) > -1)\n      return BIDI;\n\n    if(string.indexOf(LTR_MARK) > -1)\n      return LTR;\n\n    if(string.indexOf(RTL_MARK) > -1)\n      return RTL;\n\n    var hasRtl = hasDirectionCharacters(string, RTL);\n    var hasLtr = hasDirectionCharacters(string, LTR);\n \n    if(hasRtl && hasLtr)\n      return BIDI;\n\n    if(hasLtr)\n      return LTR;\n\n    if(hasRtl)\n      return RTL;\n\n    return NODI;\n  }\n  /**\n   * Determine if a string has characters in right-to-left or left-to-right Unicode blocks\n   * @param {string} string - String to check for characters\n   * @param {string} direction - Direction to check. Either 'ltr' or 'rtl' string\n   * @returns {boolean} - True if given string has direction specific characters, False otherwise\n  */\n  function hasDirectionCharacters(string, direction) {\n    var i, char, range, charIsRtl,\n        hasRtl = false,\n        hasLtr = false,\n        hasDigit = false;\n\n    hasDigit = (string.search(/[0-9]/) > -1);\n\n    // Remove white space and non directional characters\n    string = string.replace(/[\\s\\n\\0\\f\\t\\v\\'\\\"\\-0-9\\+\\?\\!]+/gm, '');\n\n    // Loop through each character\n    for(i=0; i<string.length; i++) {\n      char = string.charAt(i);\n\n      // Assume character is not rtl\n      charIsRtl = false;\n\n      // Test each character against all ltr script ranges\n      for (range in rtlSciriptRanges) {\n\n        if (rtlSciriptRanges.hasOwnProperty(range)) {\n\n          if ( isInScriptRange( char,\n            rtlSciriptRanges[range][0],\n            rtlSciriptRanges[range][1]) ){\n\n            // If character is rtl, set rtl flag (hasRtl) for string to true\n            hasRtl = true;\n\n            // Set rtl flag for this character to true\n            charIsRtl = true;\n          }\n        }\n      }\n\n      // If this character is *not* rtl then it is ltr and string has\n      // ltr characters\n      if(charIsRtl === false) {\n        hasLtr = true;\n      }\n    }\n\n    if(direction === RTL)\n      return hasRtl;\n    if(direction === LTR)\n      return hasLtr || (!hasRtl && hasDigit);\n  }\n\n  /**\n   * Checks if a a character is in a Unicode block range\n   * @param {string} char - The character to check. An string with only one character\n   * @param {string} from - Starting Unicode code of block in hexadecimal. Example: \"2D30\"\n   * @param {string} to - Ending Unicode code of block in hexadecimal. Example: \"2F30\"\n   * @returns {boolean} - true if char is in range.\n  */\n  function isInScriptRange(char, from, to) {\n    var charCode = char.charCodeAt(0),\n        fromCode = parseInt(from, 16),\n        toCode = parseInt(to, 16);\n\n    return charCode > fromCode && charCode < toCode;\n  }\n\n  /**\n   * Monkey-patch String global object to expose getDirection method\n  */\n   function patchStringPrototype () {\n    String.prototype.getDirection = function() {\n      return getDirection(this.valueOf());\n    };\n  }\n\n  // TODO make it AMD friendly\n  if(typeof exports !== 'undefined') {\n    exports.getDirection = getDirection;\n    exports.patch = patchStringPrototype;\n  } else {\n    this.stringDirection = {\n      getDirection: getDirection,\n      patch: patchStringPrototype\n    };\n  }\n\n}).call(this);\n", "import tags from 'language-tags';\nimport stringDirection from 'string-direction';\n\nimport type { Tag, Subtag } from 'language-tags';\n\n/** @package */\nexport class Language {\n    constructor(\n        readonly sourceLanguage: string,\n        readonly description: string,\n        readonly tag: string,\n        readonly directionality: string\n    ) {}\n}\n\n/**\n * @package\n *\n * Parses a language string into a {@link Language}. Guesses missing properties.\n * TODO: this should be refactored (more than it has been since this comment was\n * initially written).\n *\n * @see\n * {http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry}\n */\nexport const parseLanguage = (\n    sourceLanguage: string,\n    sample: string\n): Language => {\n    const directionality = getDirectionality(sample);\n\n    let description = sourceLanguage.trim();\n    let tag = description;\n\n    const parts = sourceLanguage.match(/^([^(]+)\\((.*)\\)\\s*$/);\n\n    if (parts && parts.length >= 2) {\n        return new Language(\n            sourceLanguage,\n            parts[1].trim(),\n            parts[2].trim(),\n            directionality\n        );\n    }\n    // First check whether `sourceLanguage` is a known IANA subtag like 'en' or 'en-GB'\n    const languageFromTag = getLanguageFromSubtag(sourceLanguage.split('-')[0]);\n\n    if (languageFromTag == null) {\n        const language = getLanguageFromDescription(description);\n\n        if (typeof language === 'object' && language.data.subtag != null) {\n            tag = language.data.subtag;\n        }\n    } else {\n        description = languageFromTag.descriptions()[0];\n    }\n\n    return new Language(sourceLanguage, description, tag, directionality);\n};\n\n/**\n * Performs IANA search to find language object with provided description.\n */\nconst getLanguageFromDescription = (description: string) =>\n    description.trim() === ''\n        ? ''\n        : tags.search(description).find(isLanguage) ?? '';\n\n/**\n * Performs IANA search to find language object with provided subtag.\n */\nconst getLanguageFromSubtag = (subtag: string) =>\n    subtag.trim() === '' ? null : tags.subtags(subtag).find(isLanguage) ?? null;\n\nconst isLanguage = (object: Tag | Subtag) => object.data.type === 'language';\n\nenum Directionality {\n    /**\n     * @default (?)\n     * @see {@link getDirectionality}\n     */\n    LTR = 'ltr',\n    RTL = 'rtl',\n}\n\n/**\n * Obtains the directionality of a text sample.\n *\n * TODO: According to the prior JSDoc, the default is supposed to be\n * {@link Directionality.LTR}, but the logic suggests the opposite.\n */\nconst getDirectionality = (sample: string) => {\n    const direction = stringDirection.getDirection(sample);\n\n    if (direction !== Directionality.LTR) {\n        return Directionality.RTL;\n    }\n\n    return direction;\n};\n", "/**\n * @package\n *\n * Transforms XForm label and hint textnode content with a subset of Markdown into HTML\n *\n * Supported:\n * - `_`, `__`, `*`, `**`, `[]()`, `#`, `##`, `###`, `####`, `#####`,\n * - span tags and html-encoded span tags,\n * - single-level unordered markdown lists and single-level ordered markdown lists\n * - newline characters\n *\n * Also HTML encodes any unsupported HTML tags for safe use inside web-based clients\n */\nexport const markdownToHTML = (text: string): string => {\n    // note: in JS $ matches end of line as well as end of string, and ^ both beginning of line and string\n    const html = text\n        // html encoding of < because libXMLJs Element.text() converts html entities\n        .replace(/</gm, '&lt;')\n        // html encoding of < because libXMLJs Element.text() converts html entities\n        .replace(/>/gm, '&gt;')\n        // span\n        .replace(\n            /&lt;\\s?span([^/\\n]*)&gt;((?:(?!&lt;\\/).)+)&lt;\\/\\s?span\\s?&gt;/gm,\n            createSpan\n        )\n        // sup\n        .replace(\n            /&lt;\\s?sup(?:[^/\\n]*)&gt;((?:(?!&lt;\\/).)+)&lt;\\/\\s?sup\\s?&gt;/gm,\n            createSup\n        )\n        // sub\n        .replace(\n            /&lt;\\s?sub(?:[^/\\n]*)&gt;((?:(?!&lt;\\/).)+)&lt;\\/\\s?sub\\s?&gt;/gm,\n            createSub\n        )\n        // \"\\\" will be used as escape character for *, _\n        .replace(/&/gm, '&amp;')\n        .replace(/\\\\\\\\/gm, '&92;')\n        .replace(/\\\\\\*/gm, '&42;')\n        .replace(/\\\\_/gm, '&95;')\n        .replace(/\\\\#/gm, '&35;')\n        // strong\n        .replace(/__(.*?)__/gm, '<strong>$1</strong>')\n        .replace(/\\*\\*(.*?)\\*\\*/gm, '<strong>$1</strong>')\n        // emphasis\n        .replace(/(^|\\W)_([^\\s][^_\\n]*)_(\\W|$)/gm, '$1<em>$2</em>$3')\n        .replace(/\\*([^\\s][^*\\n]*)\\*/gm, '<em>$1</em>')\n        // links\n        .replace(/\\[([^\\]]*)\\]\\(([^)]+)\\)/gm, createAnchor)\n        // headers\n        .replace(/^\\s*(#{1,6})\\s?([^#][^\\n]*)(\\n|$)/gm, createHeader)\n        // unordered lists\n        .replace(/^((\\*|\\+|-) (.*)(\\n|$))+/gm, createUnorderedList)\n        // ordered lists, which have to be preceded by a newline since numbered labels are common\n        .replace(/(\\n([0-9]+\\.) (.*))+$/gm, createOrderedList)\n        // newline characters followed by <ul> tag\n        .replace(/\\n(<ul>)/gm, '$1')\n        // reverting escape of special characters\n        .replace(/&35;/gm, '#')\n        .replace(/&95;/gm, '_')\n        .replace(/&92;/gm, '\\\\')\n        .replace(/&42;/gm, '*')\n        .replace(/&amp;/gm, '&')\n        // paragraphs\n        .replace(/([^\\n]+)\\n{2,}/gm, createParagraph)\n        // any remaining newline characters\n        .replace(/([^\\n]+)\\n/gm, '$1<br>');\n\n    return html;\n};\n\ntype Matches = [string, ...string[]];\n\ntype Replacer<M extends Matches> = (...args: M) => string;\n\n/* eslint-disable -- the default formatting of this was unreadable */\nconst ignoreMatch = <M extends Matches>(fn: Replacer<M>) => {\n    return (_match: string, ...args: M) => fn(...args);\n};\n/* eslint-enable */\n\nconst createAnchor = ignoreMatch(\n    (label: string, href: string) =>\n        `<a href=\"${encodeURI(\n            href\n        )}\" rel=\"noopener\" target=\"_blank\">${label}</a>`\n);\n\n/**\n * @param hashtags - Before header text. `#` gives `<h1>`, `####` gives `<h4>`.\n * @param content - Header text.\n */\nconst createHeader = ignoreMatch((hashtags: string, content: string) => {\n    const level = hashtags.length;\n\n    return `<h${level}>${content.replace(/#+$/, '')}</h${level}>`;\n});\n\nconst createUnorderedList = (match: string) => {\n    const items = match.replace(/(?:\\*|\\+|-)(.*)\\n?/gm, createItem);\n\n    return `<ul>${items}</ul>`;\n};\n\nconst createOrderedList = (match: string) => {\n    const startMatches = match.match(/^\\n?(?<start>[0-9]+)\\./);\n    const start =\n        startMatches && startMatches.groups && startMatches.groups.start !== '1'\n            ? ` start=\"${startMatches.groups.start}\"`\n            : '';\n    const items = match.replace(/\\n?(?:[0-9]+\\.)(.*)/gm, createItem);\n\n    return `<ol${start}>${items}</ol>`;\n};\n\nconst createItem = ignoreMatch(\n    (content: string) => `<li>${content.trim()}</li>`\n);\n\nconst createParagraph = ignoreMatch((line: string) => {\n    const trimmed = line.trim();\n    if (/^<\\/?(ul|ol|li|h|p)/i.test(trimmed)) {\n        return line;\n    }\n\n    return `<p>${trimmed}</p>`;\n});\n\nconst createSpan = ignoreMatch((attributes: string, content: string) => {\n    const sanitizedAttributes = sanitizeAttributes(attributes);\n\n    return `<span${sanitizedAttributes}>${content}</span>`;\n});\n\nconst createSup = ignoreMatch((content: string) => `<sup>${content}</sup>`);\n\nconst createSub = ignoreMatch((content: string) => `<sub>${content}</sub>`);\n\nconst sanitizeAttributes = (attributes: string) => {\n    const styleMatches = attributes.match(/( style=([\"'])[^\"']*\\2)/);\n    const style = styleMatches && styleMatches.length ? styleMatches[0] : '';\n\n    return style;\n};\n", "export const NAMESPACES = {\n    xmlns: 'http://www.w3.org/2002/xforms',\n    orx: 'http://openrosa.org/xforms',\n    h: 'http://www.w3.org/1999/xhtml',\n    xsl: 'http://www.w3.org/1999/XSL/Transform',\n} as const;\n", "const TEMPORARY_HOST = 'http://example.com';\n\n/**\n * @package\n *\n * @param value - a fully qualified URL, or a relative path\n */\nexport const escapeURLPath = (value: string): string => {\n    const [scheme] = value.match(/^[a-z]+:/) ?? [];\n    const isFullyQualified = scheme != null;\n\n    /**\n     * Browser implementations of `URL` do not escape URLs with unknown schemes\n     * like `jr:, nor do they escape known URLs without a domain like `file:`.\n     * To work around this limitation, we use a temporary HTTP host to escape\n     * `jr:` URL paths.\n     */\n    const urlString = isFullyQualified\n        ? value.replace(/^jr:\\/*/, 'http://')\n        : `${TEMPORARY_HOST}/${value.replace(/^\\//, '')}`;\n\n    const url = new URL(urlString);\n\n    if (isFullyQualified) {\n        return url.href.replace('http:', scheme);\n    }\n\n    const { pathname, search } = url;\n    const path = value.startsWith('/') ? pathname : pathname.replace(/^\\//, '');\n\n    return `${path}${search}`;\n};\n\n/** @package */\nexport const getMediaPath = (\n    mediaMap: Record<string, string>,\n    mediaURL: string\n) => {\n    const mediaPath = mediaURL.match(/jr:\\/\\/[\\w-]+\\/(.+)/);\n\n    if (mediaPath == null) {\n        return escapeURLPath(mediaURL);\n    }\n\n    const path = escapeURLPath(mediaPath[1]);\n    const value = mediaMap[path];\n\n    return value || escapeURLPath(mediaURL);\n};\n", "import { DOMParser, XPathResult, XSLTProcessor } from 'enketo-transformer/dom';\nimport type LibXMLJS from 'libxmljs';\nimport type { DOM } from './dom/abstract';\nimport { NodeTypes } from './dom/shared';\nimport xslForm from './xsl/openrosa2html5form.xsl?raw';\nimport xslModel from './xsl/openrosa2xmlmodel.xsl?raw';\nimport { parseLanguage } from './language';\nimport { markdownToHTML } from './markdown';\nimport { NAMESPACES } from './shared';\nimport { escapeURLPath, getMediaPath } from './url';\n\nexport type TransformPreprocess = (\n    this: typeof LibXMLJS,\n    doc: LibXMLJS.Document\n) => LibXMLJS.Document;\n\ntype NodeOnly<T> = [typeof ENV] extends ['web'] ? undefined : T;\n\nexport interface Survey {\n    xform: string;\n    markdown?: boolean;\n    media?: Record<string, string>;\n    openclinica?: boolean | number;\n\n    /**\n     * @deprecated\n     *\n     * Only supported in Node environments.\n     */\n    preprocess?: NodeOnly<TransformPreprocess>;\n\n    theme?: string;\n}\n\nexport type TransformedSurvey<T = unknown> = Omit<T, keyof Survey> & {\n    form: string;\n    languageMap: Record<string, string>;\n    model: string;\n    transformerVersion: string;\n};\n\nexport type Transform = <T extends Survey>(\n    survey: T\n) => Promise<TransformedSurvey<T>>;\n\nconst getPreprocess = (\n    survey: Survey\n): typeof ENV extends 'web' ? void : TransformPreprocess | void => {\n    if (String(ENV) === 'node' && typeof survey.preprocess === 'function') {\n        return survey.preprocess;\n    }\n};\n\n/**\n * Performs XSLT transformation on XForm and process the result.\n */\nexport const transform: Transform = async (survey) => {\n    const { xform, markdown, media, openclinica, theme } = survey;\n\n    const xsltParams = openclinica\n        ? {\n              openclinica: 1,\n          }\n        : {};\n\n    const mediaMap = Object.fromEntries(\n        Object.entries(media || {}).map((entry) => entry.map(escapeURLPath))\n    );\n    const domParser = new DOMParser();\n    const xslFormDoc = domParser.parseFromString(xslForm, 'text/xml');\n\n    let xformDoc: DOM.Document = domParser.parseFromString(xform, 'text/xml');\n\n    const preprocess = getPreprocess(survey);\n\n    if (typeof preprocess === 'function') {\n        const { libxmljs } = await import('libxslt');\n\n        // This passes with the Node and test configs, but now fails with the\n        // web config... where it is never used. Ignoring the error after\n        // several futile, probably pointless, attempts to appease the compiler.\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment -- ^\n        // @ts-ignore\n        xformDoc = preprocess.call(libxmljs, xformDoc as LibXMLJS.Document);\n    }\n\n    processBinaryDefaults(xformDoc, mediaMap);\n    processItemsets(xformDoc);\n\n    const htmlDoc = xslTransform(xslFormDoc, xformDoc, xsltParams);\n\n    correctHTMLDocHierarchy(htmlDoc);\n    correctAction(htmlDoc, 'setgeopoint');\n    correctAction(htmlDoc, 'setvalue');\n    transformAppearances(htmlDoc);\n    replaceTheme(htmlDoc, theme);\n    replaceMediaSources(htmlDoc, mediaMap);\n\n    const languageMap = replaceLanguageTags(htmlDoc);\n    const form =\n        markdown !== false\n            ? renderMarkdown(htmlDoc, mediaMap)\n            : docToString(htmlDoc);\n    const xslModelDoc = domParser.parseFromString(xslModel, 'text/xml');\n    const xmlDoc = xslTransform(xslModelDoc, xformDoc);\n\n    correctModelNamespaces(xslModelDoc, xformDoc, xmlDoc);\n    replaceMediaSources(xmlDoc, mediaMap);\n    addInstanceIdNodeIfMissing(xmlDoc);\n\n    const model = docToString(xmlDoc);\n\n    // @ts-expect-error - This fails because `xform` is not optional, but this is API-consistent behavior.\n    delete survey.xform;\n    delete survey.media;\n    delete survey.preprocess;\n    delete survey.markdown;\n    delete survey.openclinica;\n\n    return Object.assign(survey, {\n        form,\n        model,\n        languageMap,\n        transformerVersion: PACKAGE_VERSION,\n    });\n};\n\ninterface XSLTParams {\n    openclinica?: number;\n}\n\nconst xslTransform = (\n    xslDoc: DOM.Document,\n    xmlDoc: DOM.Document,\n    xsltParams: XSLTParams = {} as XSLTParams\n) => {\n    const xsltProcessor = new XSLTProcessor();\n\n    xsltProcessor.importStylesheet(xslDoc);\n\n    Object.entries(xsltParams).forEach(([key, value]) => {\n        xsltProcessor.setParameter(null, key, value);\n    });\n\n    return xsltProcessor.transformToDocument(xmlDoc);\n};\n\nconst getNamespaceResolver = (namespaces: Record<string, string>) => ({\n    lookupNamespaceURI: (prefix: string) => namespaces[prefix] ?? null,\n});\n\nconst isDocument = (node: DOM.Node | DOM.Document): node is DOM.Document =>\n    node.nodeType === NodeTypes.DOCUMENT_NODE;\n\nconst evaluateXPathExpression = (\n    context: DOM.Document | DOM.Element,\n    expression: string,\n    resultType: DOM.XPathResultType,\n    namespaces?: Record<string, string>\n) => {\n    const namespaceResolver =\n        namespaces == null ? null : getNamespaceResolver(namespaces);\n    const doc = isDocument(context) ? context : context.ownerDocument;\n\n    if (doc == null) {\n        throw new Error('Could not find owner document');\n    }\n\n    return doc.evaluate(expression, context, namespaceResolver, resultType);\n};\n\nconst getNodesByXPathExpression = <\n    T extends DOM.Element | DOM.Attr = DOM.Element,\n>(\n    context: DOM.Document | DOM.Element,\n    expression: string,\n    namespaces?: Record<string, string>\n) => {\n    const results: T[] = [];\n    const result = evaluateXPathExpression(\n        context,\n        expression,\n        XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,\n        namespaces\n    );\n\n    for (let i = 0; i < (result.snapshotLength ?? 0); i += 1) {\n        results.push(result.snapshotItem?.(i) as DOM.Node as T);\n    }\n\n    return results;\n};\n\nconst getNodeByXPathExpression = <\n    T extends DOM.Element | DOM.Attr = DOM.Element,\n>(\n    context: DOM.Document | DOM.Element,\n    expression: string,\n    namespaces?: Record<string, string>\n) => {\n    const { singleNodeValue } = evaluateXPathExpression(\n        context,\n        expression,\n        XPathResult.FIRST_ORDERED_NODE_TYPE,\n        namespaces\n    );\n\n    return singleNodeValue as T | null;\n};\n\nconst processBinaryDefaults = (\n    doc: DOM.Document,\n    mediaMap: Record<string, string>\n) => {\n    getNodesByXPathExpression(\n        doc,\n        '/h:html/h:head/xmlns:model/xmlns:bind[@type=\"binary\"]',\n        NAMESPACES\n    ).forEach((bind) => {\n        const nodeset = bind.getAttribute('nodeset');\n\n        if (nodeset) {\n            const path = `/h:html/h:head/xmlns:model/xmlns:instance${nodeset.replace(\n                /\\//g,\n                '/xmlns:'\n            )}`;\n            const dataNode = getNodeByXPathExpression(doc, path, NAMESPACES);\n\n            if (dataNode) {\n                const text = dataNode.textContent ?? '';\n\n                // Very crude URL checker which is fine for now,\n                // because at this point we don't expect anything other than jr://\n                if (/^[a-zA-Z]+:\\/\\//.test(text)) {\n                    const value = getMediaPath(mediaMap, text);\n                    const escapedText = escapeURLPath(text);\n\n                    dataNode.setAttribute('src', value);\n                    dataNode.textContent = escapedText;\n                }\n            }\n        }\n    });\n};\n\n/**\n * Correct some <setvalue>/<odk:setgeopoint> issues in the XSL stylesheets.\n * This is much easier to correct in javascript than in XSLT\n */\nconst correctAction = (\n    doc: DOM.Document,\n    localName: 'setvalue' | 'setgeopoint' = 'setvalue'\n) => {\n    /*\n     * See setvalue.xml (/data/person/age_changed). A <setvalue> inside a form control results\n     * in one label.question with a nested label.setvalue which is weird syntax (and possibly invalid HTML).\n     */\n    getNodesByXPathExpression(\n        doc,\n        `//*[contains(@class, \"question\")]//label/input[@data-${localName}]`\n    ).forEach((setValueEl) => {\n        const { parentElement } = setValueEl;\n\n        if (parentElement != null) {\n            const clone = setValueEl.cloneNode(true);\n\n            parentElement.replaceWith(clone);\n        }\n    });\n\n    /*\n     * See setvalue.xml (/data/person/age). A <setvalue> inside a repeat to set a default value that also has a question with the same name, results\n     * in one .question and .setvalue with the same name, which will leads to all kinds of problems in enketo-core\n     * as name is presumed to be unique.\n     *\n     * Note that a label.setvalue is always to set a default value (with odk-new-repeat, odk-instance-first-load), never\n     * a value change directive (with xforms-value-changed)\n     */\n    getNodesByXPathExpression(\n        doc,\n        `//label[contains(@class, \"${localName}\")]/input[@data-${localName}]`\n    ).forEach((setValueEl) => {\n        const name = setValueEl.getAttribute('name');\n        const questionSameName = getNodeByXPathExpression(\n            doc,\n            `//*[@name=\"${name}\" and ( contains(../@class, 'question') or contains(../../@class, 'option-wrapper')) and not(@type='hidden')]`\n        );\n        if (questionSameName) {\n            // Note that if the question has radiobuttons or checkboxes only the first of those gets the setvalue attributes.\n            [`data-${localName}`, 'data-event'].forEach((name) => {\n                questionSameName.setAttribute(\n                    name,\n                    setValueEl.getAttribute(name) ?? name\n                );\n            });\n            setValueEl.parentElement?.remove();\n        }\n    });\n};\n\nconst replaceTheme = (doc: DOM.Document, theme?: string) => {\n    const HAS_THEME = /(theme-)[^\"'\\s]+/;\n\n    if (!theme) {\n        return;\n    }\n\n    const form = getNodeByXPathExpression(doc.documentElement, '/root/form');\n\n    if (form == null) {\n        throw new Error('Form is missing');\n    }\n\n    const formClass = form.getAttribute('class');\n\n    if (formClass != null && HAS_THEME.test(formClass)) {\n        form.setAttribute('class', formClass.replace(HAS_THEME, `$1${theme}`));\n    } else {\n        form.setAttribute('class', `${formClass ?? ''} theme-${theme}`);\n    }\n};\n\nconst replaceMediaSources = (\n    root: DOM.Document,\n    mediaMap?: Record<string, string>\n) => {\n    if (!mediaMap) {\n        return;\n    }\n\n    // iterate through each element with a src attribute\n    getNodesByXPathExpression(root, '//*[@src] | //a[@href]').forEach(\n        (mediaEl) => {\n            const attribute =\n                mediaEl.nodeName.toLowerCase() === 'a' ? 'href' : 'src';\n            const src = mediaEl.getAttribute(attribute);\n\n            if (src == null) {\n                return;\n            }\n\n            const replacement = getMediaPath(mediaMap, src);\n\n            if (replacement) {\n                mediaEl.setAttribute(attribute, replacement);\n            }\n        }\n    );\n\n    // add form logo <img> element if applicable\n    const formLogo = mediaMap['form_logo.png'];\n    const formLogoEl = getNodeByXPathExpression(\n        root,\n        '//*[@class=\"form-logo\"]'\n    );\n    if (formLogo && formLogoEl) {\n        const formLogoImg = root.createElement('img');\n\n        formLogoImg.setAttribute('src', formLogo);\n        formLogoImg.setAttribute('alt', 'form logo');\n\n        formLogoEl.append(formLogoImg);\n    }\n};\n\n/**\n * Replaces all lang attributes to the valid IANA tag if found.\n * Also add the dir attribute to the languages in the language selector.\n *\n * @see http://www.w3.org/International/questions/qa-choosing-language-tags\n */\nconst replaceLanguageTags = (doc: DOM.Document) => {\n    const languageMap: Record<string, string> = {};\n\n    const languageElements = getNodesByXPathExpression(\n        doc,\n        '/root/form/select[@id=\"form-languages\"]/option'\n    );\n\n    // List of parsed language objects\n    const languages = languageElements.map((el) => {\n        const lang = el.textContent ?? '';\n\n        return parseLanguage(lang, getLanguageSampleText(doc, lang));\n    });\n\n    // forms without itext and only one language, still need directionality info\n    if (languages.length === 0) {\n        languages.push(parseLanguage('', getLanguageSampleText(doc, '')));\n    }\n\n    // add or correct dir and value attributes, and amend textcontent of options in language selector\n    languageElements.forEach((el, index) => {\n        const val = el.getAttribute('value');\n\n        if (val && val !== languages[index].tag) {\n            languageMap[val] = languages[index].tag;\n        }\n\n        el.setAttribute('data-dir', languages[index].directionality);\n        el.setAttribute('value', languages[index].tag);\n        el.textContent = languages[index].description;\n    });\n\n    // correct lang attributes\n    languages.forEach(({ sourceLanguage, tag }) => {\n        if (sourceLanguage === tag) {\n            return;\n        }\n        getNodesByXPathExpression(\n            doc,\n            `/root/form//*[@lang=\"${sourceLanguage}\"]`\n        ).forEach((el) => {\n            el.setAttribute('lang', tag);\n        });\n    });\n\n    // correct default lang attribute\n    const langSelectorElement = getNodeByXPathExpression(\n        doc,\n        '/root/form/*[@data-default-lang]'\n    );\n    if (langSelectorElement) {\n        const defaultLang =\n            langSelectorElement.getAttribute('data-default-lang');\n\n        languages.some(({ sourceLanguage, tag }) => {\n            if (sourceLanguage === defaultLang) {\n                langSelectorElement.setAttribute('data-default-lang', tag);\n\n                return true;\n            }\n\n            return false;\n        });\n    }\n\n    return languageMap;\n};\n\n/**\n * Obtains a non-empty hint text or other text sample of a particular form language.\n */\nconst getLanguageSampleText = (doc: DOM.Document, language: string) => {\n    // First find non-empty text content of a hint with that lang attribute.\n    // If not found, find any span with that lang attribute.\n    const langSampleEl =\n        getNodeByXPathExpression(\n            doc,\n            `/root/form//span[contains(@class, \"or-hint\") and @lang=\"${language}\" and normalize-space() and not(./text() = '-')]`\n        ) ||\n        getNodeByXPathExpression(\n            doc,\n            `/root/form//span[@lang=\"${language}\" and normalize-space() and not(./text() = '-')]`\n        );\n\n    return langSampleEl?.textContent?.trim() || 'nothing';\n};\n\n/**\n * Temporary function to add a /meta/instanceID node if this is missing.\n * This used to be done in enketo-xslt but was removed when support for namespaces was added.\n */\nconst addInstanceIdNodeIfMissing = (doc: DOM.Document) => {\n    const xformsPath =\n        '/xmlns:root/xmlns:model/xmlns:instance/*/xmlns:meta/xmlns:instanceID';\n    const openrosaPath =\n        '/xmlns:root/xmlns:model/xmlns:instance/*/orx:meta/orx:instanceID';\n    const instanceIdEl = getNodeByXPathExpression(\n        doc,\n        `${xformsPath} | ${openrosaPath}`,\n        NAMESPACES\n    );\n\n    if (!instanceIdEl) {\n        const rootEl = getNodeByXPathExpression(\n            doc,\n            '/xmlns:root/xmlns:model/xmlns:instance/*',\n            NAMESPACES\n        );\n        const metaEl = getNodeByXPathExpression(\n            doc,\n            '/xmlns:root/xmlns:model/xmlns:instance/*/xmlns:meta',\n            NAMESPACES\n        );\n\n        const instanceID = doc.createElementNS(NAMESPACES.xmlns, 'instanceID');\n\n        if (metaEl) {\n            metaEl.append(instanceID);\n        } else if (rootEl) {\n            const meta = doc.createElementNS(NAMESPACES.xmlns, 'meta');\n\n            rootEl.append(meta);\n            meta.append(instanceID);\n        }\n    }\n};\n\n/**\n * Converts a subset of Markdown in all textnode children of labels and hints into HTML\n */\nconst renderMarkdown = (\n    htmlDoc: DOM.Document,\n    mediaMap: Record<string, string>\n) => {\n    const replacements: Record<string, string> = {};\n\n    // First turn all outputs into text so *<span class=\"or-output></span>* can be detected\n    getNodesByXPathExpression(\n        htmlDoc,\n        '/root/form//span[contains(@class, \"or-output\")]'\n    ).forEach((el, index) => {\n        const key = `---output-${index}`;\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const textNode = el.firstChild!.cloneNode(true);\n        replacements[key] = el.outerHTML;\n        textNode.textContent = key;\n        el.replaceWith(textNode);\n        // Note that we end up in a situation where we likely have sibling text nodes...\n    });\n\n    const domParser = new DOMParser();\n\n    // Now render markdown\n    getNodesByXPathExpression(\n        htmlDoc,\n        '/root/form//span[contains(@class, \"question-label\") or contains(@class, \"or-hint\")]'\n    ).forEach((el, index) => {\n        let key;\n        /**\n         * Using text() is done because:\n         * a) We are certain that these <span>s do not contain other elements, other than formatting/markdown <span>s.\n         * b) This avoids the need to merge any sibling text nodes that could have been created in the previous step.\n         *\n         * Note that text() will convert &gt; to >\n         */\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const original = el\n            .textContent!.replace('<', '&lt;')\n            .replace('>', '&gt;');\n        let rendered = markdownToHTML(original);\n\n        if (original !== rendered) {\n            const tempDoc = domParser.parseFromString(\n                `<root class=\"temporary-root\">${rendered}</root>`,\n                'text/html'\n            );\n\n            correctHTMLDocHierarchy(tempDoc);\n            replaceMediaSources(tempDoc, mediaMap);\n\n            rendered = docToString(tempDoc);\n            key = `$$$${index}`;\n            replacements[key] = rendered;\n            el.textContent = key;\n        }\n    });\n\n    let htmlStr = docToString(htmlDoc);\n\n    // Now replace the placeholders with the rendered HTML\n    // in reverse order so outputs are done last\n    Object.keys(replacements)\n        .reverse()\n        .forEach((key) => {\n            const replacement = replacements[key];\n            if (replacement) {\n                /**\n                 * The replacement is called as a function here so special string\n                 * replacement sequences are preserved if they appear within Markdown.\n                 *  @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_the_replacement}\n                 */\n                htmlStr = htmlStr.replace(key, () => replacement);\n            }\n        });\n\n    return htmlStr;\n};\n\nconst docToString = (doc: DOM.Document) => {\n    const { outerHTML } = doc.documentElement;\n\n    // It would be tempting to use `innerHTML`, as this is semantically\n    // equivalent. But removing the open and closing tags from `outerHTML`\n    // produces consistent namespace declarations across environments.\n    return outerHTML.replace(/^<[^>]+>/, '').replace(/<\\/[^>]+>(?!.|\\n)$/, '');\n};\n\nexport const version = VERSION;\n\nexport const sheets = {\n    xslForm,\n    xslModel,\n};\n\nexport { escapeURLPath, NAMESPACES };\n\n/**\n * Exported for backwards compatibility, prefer named imports from enketo-transformer's index module.\n */\nexport default {\n    transform,\n    version: VERSION,\n    NAMESPACES,\n    sheets,\n    escapeURLPath,\n};\n\nconst correctHTMLDocHierarchy = (doc: DOM.Document) => {\n    const { documentElement } = doc;\n\n    if (documentElement.nodeName.toLowerCase() === 'html') {\n        const root = getNodeByXPathExpression(doc, '/html/body/root');\n\n        if (root == null) {\n            throw new Error('Missing root node.');\n        }\n\n        documentElement.replaceWith(root);\n    }\n};\n\n/** @see {@link processItemsets} */\nconst substringBefore = (haystack: string, needle: string) =>\n    haystack.split(needle, 1)[0];\n\n/** @see {@link processItemsets} */\nconst substringAfter = (haystack: string, needle: string) =>\n    haystack.substring(haystack.indexOf(needle) + needle.length);\n\n/**\n * This is a replacement for the XSL template named `strip-filter`. The original\n * XSL commentary follows:\n *\n * ----------------------------------------------------------------------------\n * turns: /path/to/node[value=/some/other/node] into: /path/to/node this\n * function is probably way too aggressive but will work for xls-form generated\n * forms to do this properly a regexp:replace is required, but not supported in\n * libXML kept the recursion in, even though it is not being used right now\n * ----------------------------------------------------------------------------\n *\n * Contrary to the JSDoc comment for @see {@link processItemsets},\n * this implementation deviates from the original XSL logic, which uses\n * substrings and recursion, because it's (hopefully) much easier to understand\n * this way.\n *\n * It is *also* worth noting that in the process of migrating to browser DOM,\n * the original commentary was found to be wrong! The recursion was certainly in\n * use, and without it some snapshot tests failed.\n */\nconst stripFilter = (expression: string) => expression.replace(/\\[.*?\\]/g, '');\n\n/**\n * This is a replacement for the dynamic logic in the XSL template\n * `match=\"xf:itemset\" mode=\"labels\"`. Moving it to DOM code allows us to drop\n * our reliance on the unsupported `dyn` extension. The intent is to match the\n * naming and semantics of the original XSL logic to ensure there is no\n * potential for regressions.\n */\nconst processItemsets = (xformDoc: DOM.Document) => {\n    const itemsets = getNodesByXPathExpression(\n        xformDoc,\n        '//xmlns:itemset',\n        NAMESPACES\n    );\n\n    itemsets.forEach((itemset) => {\n        const valueEl = getNodeByXPathExpression(\n            itemset,\n            './xmlns:value',\n            NAMESPACES\n        );\n        const valueRef = valueEl?.getAttribute('ref') ?? '';\n        const labelEl = getNodeByXPathExpression(\n            itemset,\n            './xmlns:label',\n            NAMESPACES\n        );\n        const labelRef = labelEl?.getAttribute('ref') ?? '';\n        const nodeset = itemset.getAttribute('nodeset') ?? '';\n        const iwq = substringBefore(substringAfter(nodeset, 'instance('), ')');\n\n        // TODO (2023-01-15): The following comment is directly from the\n        // previous XSL implementation. But because we *do* now implement this\n        // in a general purpose language, we can address these limitations.\n\n        // Needs to also deal with randomize(instance(\"id\")/path/to/node), randomize(instance(\"id\")/path/to/node, 3)\n        // Super inelegant and not robust without regexp:match\n        let instancePathTemp: string;\n\n        const nodesetIncludesRandomize = nodeset.includes('randomize(');\n\n        if (nodesetIncludesRandomize && nodeset.includes(',')) {\n            instancePathTemp = substringBefore(\n                substringAfter(nodeset, ')'),\n                ','\n            );\n        } else if (nodesetIncludesRandomize) {\n            instancePathTemp = substringBefore(\n                substringAfter(nodeset, ')'),\n                ')'\n            );\n        } else {\n            instancePathTemp = substringAfter(nodeset, ')');\n        }\n\n        const instancePath = instancePathTemp.replace(/\\//g, '/xf:');\n        const instancePathNoFilter = stripFilter(instancePath);\n        const instanceId = iwq.substring(1, iwq.length - 1);\n        const itextPath = `/h:html/h:head/xf:model/xf:instance[@id=\"${instanceId}\"]${instancePathNoFilter}`;\n\n        itemset.setAttribute('valueRef', valueRef);\n        itemset.setAttribute('labelRef', labelRef);\n        itemset.setAttribute('itextPath', `${itextPath}`);\n\n        const [, labelNodeName] = labelRef.match(/itext\\((.*)\\)/) ?? [];\n\n        if (labelNodeName != null) {\n            const labelPath = `${itextPath.replace(\n                /\\/xf:/g,\n                '/xmlns:'\n            )}/*[name() = \"${labelNodeName}\"]`;\n            const items = getNodesByXPathExpression(\n                xformDoc,\n                labelPath,\n                NAMESPACES\n            );\n\n            itemset.append(...items.map((item) => item.cloneNode(true)));\n        }\n    });\n};\n\n/**\n * This is a replacement for the logic previously implemented in the\n * `appearance` template in `openrosa2html5form.xsl`. That template now\n * transforms existing appearance values directly to a `data-appearance`\n * attribute, and the previous logic is applied here based on those values.\n */\nconst transformAppearances = (doc: DOM.Document) => {\n    const appearanceElements = getNodesByXPathExpression(\n        doc,\n        '//*[@data-appearances]'\n    );\n\n    appearanceElements.forEach((element) => {\n        const selectType = element.hasAttribute('data-appearances-select-type');\n\n        if (selectType) {\n            element.removeAttribute('data-appearances-select-type');\n        }\n\n        const appearances =\n            element\n                .getAttribute('data-appearances')\n                ?.trim()\n                .toLowerCase()\n                .split(/\\s+/) ?? [];\n\n        const appearanceClasses = appearances.flatMap((appearance) => {\n            const results = [`or-appearance-${appearance}`];\n\n            // Convert deprecated appearances, but leave the deprecated ones.\n            if (selectType) {\n                if (appearance === 'horizontal') {\n                    results.push('or-appearance-columns');\n                }\n\n                if (appearance === 'horizontal-compact') {\n                    results.push('or-appearance-columns-pack');\n                }\n\n                if (appearance === 'compact') {\n                    results.push(\n                        'or-appearance-columns-pack',\n                        'or-appearance-no-buttons'\n                    );\n                }\n\n                if (appearance.startsWith('compact-')) {\n                    results.push(\n                        appearance.replace('compact-', ''),\n                        'or-appearance-no-buttons'\n                    );\n                }\n            }\n\n            return results;\n        });\n\n        const classes =\n            element.getAttribute('class')?.trim()?.split(/\\s+/) ?? [];\n\n        const className = classes\n            .flatMap((className) =>\n                className === 'or-appearances-placeholder'\n                    ? appearanceClasses\n                    : className\n            )\n            .join(' ');\n\n        element.setAttribute('class', className);\n        element.removeAttribute('data-appearances');\n    });\n};\n\nconst XMLNS_URI = 'http://www.w3.org/2000/xmlns/';\n\ndeclare const document: DOM.Document | undefined;\n\n/**\n * This addresses a difference in how Firefox treats XML namespace declarations\n * versus other browsers, as well as `libxslt`. In `openrosa2xmlmodel.xsl`, it's\n * expected that `xmlns` and `xmlns:*` are treated as attributes, but evidently\n * this is not the case in Firefox. So for consistency we copy the namespace\n * declarations in the browser DOM.\n *\n * An important note: understanding what the actual behavior originally was\n * turned out to be rather difficult, so this is the current behavior (which may\n * not exactly be *expected* e.g. by Enketo Core):\n *\n * For each namespace declaration defined on the XForm's root `html` element,\n * assign them to the transformed model's primary `instance` element, **except if**:\n *\n * - The namespace is also defined on the `model`.\n * - The namespace prefix is used on any of the `model`'s attributes.\n * - The namespace is also defined in `openrosa2xmlmodel.xsl`.\n *\n * TODO (2023-01-16):\n *\n * - All of the exceptions described above are either known bugs or likely to be.\n *\n * - This leaves very little remaining responsibilities of\n *   `openrosa2xmlmodel.xsl`. We should seriously consider moving the remainder\n *   to DOM code.\n */\nconst correctModelNamespaces = (\n    xslDoc: DOM.Document,\n    xformDoc: DOM.Document,\n    modelDoc: DOM.Document\n) => {\n    if (typeof document === 'undefined') {\n        return;\n    }\n\n    const { documentElement: xslRoot } = xslDoc;\n    const instanceRoots = getNodesByXPathExpression(\n        modelDoc,\n        '/xmlns:root/xmlns:model/xmlns:instance/*',\n        NAMESPACES\n    );\n    const model = instanceRoots[0].parentElement?.parentElement;\n    const xformModel = getNodeByXPathExpression(\n        xformDoc,\n        '/h:html/h:head/xmlns:model',\n        NAMESPACES\n    );\n\n    if (model == null || xformModel == null) {\n        throw new Error('XForm is missing a model element.');\n    }\n\n    instanceRoots.forEach((instanceRoot) => {\n        const xformModelAttrNamespaces = [...xformModel.attributes]\n            .filter(\n                ({ name }) => name !== 'xmlns' && !name.startsWith('xmlns:')\n            )\n            .map(({ namespaceURI }) => namespaceURI);\n\n        const missingNamespaceAttrs = [\n            ...xformDoc.documentElement.attributes,\n        ].filter(\n            ({ name, value }) =>\n                (name === 'xmlns' || name.startsWith('xmlns:')) &&\n                !xslRoot.hasAttribute(name) &&\n                !xformModelAttrNamespaces.includes(value) &&\n                !instanceRoot.hasAttribute(name)\n        );\n\n        missingNamespaceAttrs.forEach(({ name, value }) => {\n            instanceRoot.setAttributeNS(XMLNS_URI, name, value);\n        });\n    });\n};\n"],
  "mappings": "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",
  "names": ["DOMParser", "XPathResult", "XSLTProcessor", "NodeTypes", "xslForm", "xslModel", "index", "require$$0", "registry", "require$$1", "Subtag_1", "Subtag", "subtag", "type", "types", "i", "record", "error", "code", "message", "err", "preferred", "script", "require$$2", "Tag_1", "Tag", "tag", "codes", "data", "subtags", "l", "errors", "language", "found", "variant", "priority", "next", "p", "c", "a", "require$$3", "tags", "lib", "result", "query", "all", "test", "description", "b", "macrolanguage", "results", "require$$4", "require$$5", "LTR_MARK", "RTL_MARK", "LTR", "RTL", "BIDI", "NODI", "rtlSciriptRanges", "getDirection", "string", "hasRtl", "hasDirectionCharacters", "hasLtr", "direction", "char", "range", "charIsRtl", "hasDigit", "isInScriptRange", "from", "to", "charCode", "fromCode", "toCode", "patchStringPrototype", "exports", "this", "Language", "sourceLanguage", "directionality", "parseLanguage", "sample", "getDirectionality", "parts", "languageFromTag", "getLanguageFromSubtag", "getLanguageFromDescription", "_a", "isLanguage", "object", "stringDirection", "markdownToHTML", "text", "createSpan", "createSup", "createSub", "createAnchor", "createHeader", "createUnorderedList", "createOrderedList", "createParagraph", "ignoreMatch", "fn", "_match", "args", "label", "href", "hashtags", "content", "level", "match", "createItem", "startMatches", "start", "items", "line", "trimmed", "attributes", "sanitizeAttributes", "styleMatches", "NAMESPACES", "TEMPORARY_HOST", "escapeURLPath", "value", "scheme", "isFullyQualified", "urlString", "url", "pathname", "search", "getMediaPath", "mediaMap", "mediaURL", "mediaPath", "path", "getPreprocess", "survey", "transform", "xform", "markdown", "media", "openclinica", "theme", "xsltParams", "entry", "domParser", "xslFormDoc", "xformDoc", "preprocess", "libxmljs", "processBinaryDefaults", "processItemsets", "htmlDoc", "xslTransform", "correctHTMLDocHierarchy", "correctAction", "transformAppearances", "replaceTheme", "replaceMediaSources", "languageMap", "replaceLanguageTags", "form", "renderMarkdown", "docToString", "xslModelDoc", "xmlDoc", "correctModelNamespaces", "addInstanceIdNodeIfMissing", "model", "xslDoc", "xsltProcessor", "key", "getNamespaceResolver", "namespaces", "prefix", "isDocument", "node", "evaluateXPathExpression", "context", "expression", "resultType", "namespaceResolver", "doc", "getNodesByXPathExpression", "getNodeByXPathExpression", "singleNodeValue", "bind", "nodeset", "dataNode", "escapedText", "localName", "setValueEl", "parentElement", "clone", "name", "questionSameName", "HAS_THEME", "formClass", "root", "mediaEl", "attribute", "src", "replacement", "formLogo", "formLogoEl", "formLogoImg", "languageElements", "languages", "el", "lang", "getLanguageSampleText", "val", "langSelectorElement", "defaultLang", "langSampleEl", "rootEl", "metaEl", "instanceID", "meta", "replacements", "textNode", "original", "rendered", "tempDoc", "htmlStr", "outerHTML", "version", "sheets", "transformer_default", "documentElement", "substringBefore", "haystack", "needle", "substringAfter", "stripFilter", "itemset", "_b", "_c", "_d", "valueEl", "valueRef", "labelEl", "labelRef", "iwq", "instancePathTemp", "nodesetIncludesRandomize", "instancePath", "instancePathNoFilter", "itextPath", "labelNodeName", "labelPath", "item", "element", "selectType", "appearanceClasses", "appearance", "className", "XMLNS_URI", "modelDoc", "xslRoot", "instanceRoots", "xformModel", "instanceRoot", "xformModelAttrNamespaces", "namespaceURI"]
}
